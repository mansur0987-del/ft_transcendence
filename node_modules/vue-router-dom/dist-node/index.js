'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var history = require('history');

const ROUTE_CONTEXT = Symbol('ROUTE_CONTEXT');
const LOCATION_CONTEXT = Symbol('LOCATION_CONTEXT');

const Router = vue.defineComponent({
  name: 'Router',
  props: {
    location: {
      required: true,
      type: Object
    },
    navigator: {
      required: true,
      type: Object
    },
    action: {
      required: false,
      type: String,
      default: history.Action.Pop
    },
    static: {
      required: false,
      type: Boolean,
      default: false
    }
  },

  setup(props, {
    slots
  }) {
    vue.provide(LOCATION_CONTEXT, props);
    return () => vue.renderSlot(slots, 'default');
  }

});

const useReducer = (reducer, initialState) => {
  const state = vue.reactive(initialState);

  const dispatch = (...arg) => {
    reducer(state, ...arg);
  };

  return [vue.readonly(state), dispatch];
};

const BrowserRouter = vue.defineComponent({
  name: 'BrowserRouter',
  props: {
    window: {
      required: false,
      type: Object
    }
  },

  setup(props, {
    slots
  }) {
    const history$1 = vue.computed(() => history.createBrowserHistory({
      window: props.window
    }));
    const [state, dispatch] = useReducer((state, {
      action,
      location
    }) => {
      state.action = action;
      state.location = location;
    }, {
      action: history$1.value.action,
      location: history$1.value.location
    });
    vue.watch(history$1, history => history.listen(dispatch), {
      flush: 'sync',
      immediate: true
    });
    return () => vue.h(Router, {
      location: state.location,
      action: state.action,
      navigator: history$1.value
    }, {
      default: slots.default
    });
  }

});

const throwError = error => {
  throw new Error(`[vue-router-dom] ${error}`);
};
function assert(condition, message) {
  if (!condition) {
    throwError(message);
  }
}

const useLocation = () => {
  const locationContext = vue.inject(LOCATION_CONTEXT, null);
  assert(locationContext, `useLocation() may be used only in the context of a <Router> component.`);
  return vue.toRef(locationContext, 'location');
};

const trimTrailingSlashes = path => path.replace(/\/+$/, '');

const normalizeSlashes = path => path.replace(/\/\/+/g, '/');

const joinPaths = paths => normalizeSlashes(paths.join('/'));

const splitPath = path => normalizeSlashes(path).split('/');

const resolvePathname = (toPathname, fromPathname) => {
  const segments = splitPath(trimTrailingSlashes(fromPathname));
  const relativeSegments = splitPath(toPathname);
  relativeSegments.forEach(segment => {
    if (segment === '..') {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== '.') {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? joinPaths(segments) : '/';
};

const resolvePath = (to, fromPathname = '/') => {
  const {
    pathname: toPathname,
    search = '',
    hash = ''
  } = typeof to === 'string' ? history.parsePath(to) : to;
  const pathname = toPathname ? resolvePathname(toPathname, toPathname.startsWith('/') ? '/' : fromPathname) : fromPathname;
  return {
    pathname,
    search,
    hash
  };
};

const useRouteContext = () => vue.inject(ROUTE_CONTEXT, vue.computed(() => ({
  pathname: '',
  outlet: null,
  params: {},
  route: null
})));
const useOutlet = () => {
  const context = useRouteContext();
  return vue.computed(() => context.value.outlet);
};

const useNavigate = () => {
  const locationContext = vue.inject(LOCATION_CONTEXT, null);
  assert(locationContext, `useNavigate() may be used only in the context of a <Router> component.`);
  const navigator = vue.toRef(locationContext, 'navigator');
  const context = useRouteContext();
  const pathname = vue.computed(() => context.value.pathname);

  const navigate = (to, {
    state,
    replace = false
  } = {}) => {
    const navigatorValue = navigator.value;

    if (typeof to === 'number') {
      return navigatorValue.go(to);
    }

    const path = resolvePath(to, pathname.value);
    (replace ? navigatorValue.replace : navigatorValue.push)(path, state);
  };

  return navigate;
};

const useComputedCallback = value => value instanceof Function ? vue.computed(value) : vue.isRef(value) ? value : vue.computed(() => value);

const useResolvedPath = toValue => {
  const to = useComputedCallback(toValue);
  const context = useRouteContext();
  const pathname = vue.computed(() => context.value.pathname);
  return vue.computed(() => resolvePath(to.value, pathname.value));
};

const useHref = toValue => {
  const locationContext = vue.inject(LOCATION_CONTEXT, null);
  assert(locationContext, `useHref() may be used only in the context of a <Router> component.`);
  const navigator = vue.toRef(locationContext, 'navigator');
  const to = useComputedCallback(toValue);
  const path = useResolvedPath(to);
  return vue.computed(() => navigator.value.createHref(path.value));
};

const linkProps = {
  replace: {
    default: false,
    required: false,
    type: Boolean
  },
  tag: {
    default: 'a',
    required: false,
    type: String
  },
  to: {
    default: '',
    required: true,
    type: [String, Object]
  },
  state: {
    default: undefined,
    required: false,
    type: Object
  }
};
const Link = vue.defineComponent({
  name: 'Link',
  props: linkProps,
  emits: {
    click: null
  },

  setup(props, {
    slots,
    emit
  }) {
    const {
      to,
      replace
    } = vue.toRefs(props);
    const href = useHref(to);
    const location = useLocation();
    const path = useResolvedPath(to);
    const navigate = useNavigate();

    const handleClick = event => {
      emit('click', event);
      event.stopPropagation();
      event.preventDefault();
      const pathValue = path.value; // If the URL hasn't changed, replace instead of push.

      const replaceValue = !!replace.value || history.createPath(location.value) === history.createPath(pathValue);
      navigate(pathValue, {
        replace: replaceValue,
        state: props.state
      });
    };

    return () => vue.h(props.tag, {
      href: href.value,
      onClick: handleClick
    }, {
      default: slots.default
    });
  }

});

const MemoryRouter = vue.defineComponent({
  name: 'MemoryRouter',
  props: {
    initialEntries: {
      required: false,
      type: Array
    },
    initialIndex: {
      required: false,
      type: Number
    }
  },

  setup(props, {
    slots
  }) {
    const history$1 = vue.computed(() => history.createMemoryHistory({
      initialEntries: props.initialEntries,
      initialIndex: props.initialIndex
    }));
    const [state, dispatch] = useReducer((state, {
      action,
      location
    }) => {
      state.action = action;
      state.location = location;
    }, {
      action: history$1.value.action,
      location: history$1.value.location
    });
    vue.watch(history$1, history => history.listen(dispatch), {
      flush: 'sync',
      immediate: true
    });
    return () => vue.h(Router, {
      location: state.location,
      action: state.action,
      navigator: history$1.value
    }, {
      default: slots.default
    });
  }

});

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const useCaseSensitive = (caseSensitiveValue, stringValue) => {
  const caseSensitive = useComputedCallback(caseSensitiveValue);
  const string = useComputedCallback(stringValue);
  return vue.computed(() => {
    const stringValue = string.value;
    return caseSensitive.value ? stringValue : stringValue.toLowerCase();
  });
};

const NavLink = vue.defineComponent({
  name: 'NavLink',
  props: _objectSpread2({
    activeClassName: {
      default: '',
      required: false,
      type: String
    },
    activeStyle: {
      default: () => ({}),
      required: false,
      type: Object
    },
    caseSensitive: {
      default: false,
      required: false,
      type: Boolean
    },
    end: {
      default: false,
      required: false,
      type: Boolean
    },
    ariaCurrent: {
      default: 'page',
      type: String,
      required: false
    }
  }, linkProps),

  setup(props, {
    slots
  }) {
    const location = useLocation();
    const {
      to,
      caseSensitive
    } = vue.toRefs(props);
    const path = useResolvedPath(to);
    const locationPathname = vue.computed(() => location.value.pathname);
    const toPathname = vue.computed(() => path.value.pathname);
    const caseSensitiveLocationPathname = useCaseSensitive(caseSensitive, locationPathname);
    const caseSensitiveToPathname = useCaseSensitive(caseSensitive, toPathname);
    const isActive = vue.computed(() => {
      const locationPathname = caseSensitiveLocationPathname.value;
      const toPathname = caseSensitiveToPathname.value;
      return props.end ? locationPathname === toPathname : locationPathname.startsWith(toPathname);
    });
    const ariaCurrent = vue.computed(() => isActive.value ? props.ariaCurrent : undefined);
    const className = vue.computed(() => isActive.value && props.activeClassName);
    const style = vue.computed(() => isActive.value && props.activeStyle);
    return () => vue.h(Link, {
      style: style.value,
      class: className.value,
      to: props.to,
      ariaCurrent: ariaCurrent.value
    }, {
      default: slots.default
    });
  }

});

const Outlet = vue.defineComponent({
  name: 'Outlet',

  setup() {
    const outletElement = useOutlet();
    return () => outletElement.value;
  }

});

const Route = vue.defineComponent({
  name: 'Route',
  props: {
    path: {
      default: '',
      required: false,
      type: String
    },
    caseSensitive: {
      default: false,
      required: false,
      type: Boolean
    },
    element: {
      default: () => vue.h(Outlet),
      required: false,
      type: Object
    }
  },

  setup(props, {
    slots
  }) {
    return () => vue.renderSlot(slots, 'element', undefined, () => [props.element]);
  }

});

const compilePath = (path, caseSensitive, end) => {
  const keys = [];
  let source = '^(' + path.replace(/^\/*/, '/') // Make sure it has a leading /
  .replace(/\/?\*?$/, '') // Ignore trailing / and /*, we'll handle it below
  .replace(/[\\.*+^$?{}|()[\]]/g, '\\$&') // Escape special regex chars
  .replace(/:(\w+)/g, (_, key) => {
    keys.push(key);
    return '([^\\/]+)';
  }) + ')';

  if (path.endsWith('*')) {
    if (path.endsWith('/*')) {
      source += '\\/?'; // Don't include the / in params['*']
    }

    keys.push('*');
    source += '(.*)';
  } else if (end) {
    source += '\\/?';
  }

  if (end) source += '$';
  const flags = caseSensitive ? undefined : 'i';
  const matcher = new RegExp(source, flags);
  return [matcher, keys];
};

const safelyDecodeURIComponent = (value, paramName) => {
  try {
    return decodeURIComponent(value.replace(/\+/g, ' '));
  } catch (error) {
    assert(false, `The value for the URL param "${paramName}" will not be decoded because` + ` the string "${value}" is a malformed URL segment. This is probably` + ` due to a bad percent encoding (${error}).`);
  }
};

const matchPath = (pattern, pathname) => {
  if (typeof pattern === 'string') {
    pattern = {
      path: pattern
    };
  }

  const {
    path,
    caseSensitive = false,
    end = true
  } = pattern;
  const [matcher, paramNames] = compilePath(path, caseSensitive, end);
  const match = pathname.match(matcher);
  if (!match) return null;
  const matchedPathname = match[1];
  const values = match.slice(2);
  const params = paramNames.reduce((memo, paramName, index) => {
    memo[paramName] = safelyDecodeURIComponent(values[index], paramName);
    return memo;
  }, {});
  return {
    path,
    pathname: matchedPathname,
    params
  };
};

const paramRe = /^:\w+$/;
const dynamicSegmentValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;

const isSplat = s => s === '*';

function matchRouteBranch(branch, pathname) {
  const routes = branch[1];
  let matchedPathname = '/';
  let matchedParams = {};
  const matches = [];

  for (let i = 0; i < routes.length; ++i) {
    const route = routes[i];
    const remainingPathname = matchedPathname === '/' ? pathname : pathname.slice(matchedPathname.length) || '/';
    const routeMatch = matchPath({
      path: route.path,
      caseSensitive: route.caseSensitive,
      end: i === routes.length - 1
    }, remainingPathname);
    if (!routeMatch) return null;
    matchedPathname = joinPaths([matchedPathname, routeMatch.pathname]);
    matchedParams = _objectSpread2({}, matchedParams, {}, routeMatch.params);
    matches.push({
      route,
      pathname: matchedPathname,
      params: matchedParams
    });
  }

  return matches;
}

function compareIndexes(a, b) {
  const siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}

function stableSort(array, compareItems) {
  // This copy lets us get the original index of an item so we can preserve the
  // original ordering in the case that they sort equally.
  const copy = array.slice(0);
  array.sort((a, b) => compareItems(a, b) || copy.indexOf(a) - copy.indexOf(b));
}

function computeScore(path) {
  const segments = path.split('/');
  let initialScore = segments.length;

  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }

  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === '' ? emptySegmentValue : staticSegmentValue), initialScore);
}

function rankRouteBranches(branches) {
  const pathScores = branches.reduce((memo, [path]) => {
    memo[path] = computeScore(path);
    return memo;
  }, {}); // Sorting is stable in modern browsers, but we still support IE 11, so we
  // need this little helper.

  stableSort(branches, (a, b) => {
    const [aPath,, aIndexes] = a;
    const aScore = pathScores[aPath];
    const [bPath,, bIndexes] = b;
    const bScore = pathScores[bPath];
    return aScore !== bScore ? bScore - aScore // Higher score first
    : compareIndexes(aIndexes, bIndexes);
  });
}

function flattenRoutes(routes, branches = [], parentPath = '', parentRoutes = [], parentIndexes = []) {
  routes.forEach((route, index) => {
    const path = joinPaths([parentPath, route.path]);
    const routes = parentRoutes.concat(route);
    const indexes = parentIndexes.concat(index); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children) {
      flattenRoutes(route.children, branches, path, routes, indexes);
    }

    branches.push([path, routes, indexes]);
  });
  return branches;
}

const matchRoutes = (routes, location, basename = '') => {
  if (typeof location === 'string') {
    location = history.parsePath(location);
  }

  let pathname = location.pathname || '/';

  if (basename) {
    const base = basename.replace(/^\/*/, '/').replace(/\/+$/, '');

    if (pathname.startsWith(base)) {
      pathname = pathname === base ? '/' : pathname.slice(base.length);
    } else {
      // Pathname does not start with the basename, no match.
      return null;
    }
  }

  const branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;

  for (let i = 0; matches == null && i < branches.length; i++) {
    // TODO: Match on search, state too?
    matches = matchRouteBranch(branches[i], pathname);
  }

  return matches;
};

const createRoutesFromArray = partialRouteObjects => {
  return partialRouteObjects.map(partialRoute => {
    const route = {
      path: partialRoute.path || '/',
      caseSensitive: partialRoute.caseSensitive === true,
      element: partialRoute.element || vue.h(Outlet)
    };

    if (partialRoute.children) {
      route.children = createRoutesFromArray(partialRoute.children);
    }

    return route;
  });
};

const Provide = vue.defineComponent({
  props: {
    injectionKey: {
      required: true,
      type: [String, Symbol]
    },
    value: null
  },

  setup(props, {
    slots
  }) {
    vue.provide(props.injectionKey, vue.computed(() => props.value));
    return () => vue.renderSlot(slots, 'default');
  }

});

const useJoinPaths = pathsValue => {
  const paths = useComputedCallback(pathsValue);
  return vue.computed(() => joinPaths(paths.value));
};

const useRoutes_ = (routesValue, basenameValue = '') => {
  const routes = useComputedCallback(routesValue);
  const defaultBasename = useComputedCallback(basenameValue);
  const context = useRouteContext();
  const parentRoute = vue.computed(() => context.value.route);
  const parentPathname = vue.computed(() => context.value.pathname);
  const parentParams = vue.computed(() => context.value.params);
  const location = useLocation();
  const parentPath = vue.computed(() => parentRoute.value && parentRoute.value.path);
  vue.watchEffect(() => {
    const parentRouteValue = parentRoute.value;

    if (parentRouteValue && !parentRouteValue.path.endsWith('*')) {
      console.warn(`You rendered descendant <Routes> (or called \`useRoutes\`) at "${parentPathname.value}"` + ` (under <Route path="${parentPath.value}">) but the parent route path has no trailing "*".` + ` This means if you navigate deeper, the parent won't match anymore and therefore` + ` the child routes will never render.` + `\n\n` + `Please change the parent <Route path="${parentPath.value}"> to <Route path="${parentPath.value}/*">.`);
    }
  });
  const joinedPaths = useJoinPaths(() => [parentPathname.value, defaultBasename.value]);
  const basename = vue.computed(() => defaultBasename.value ? joinedPaths.value : parentPathname.value);
  const matches = vue.computed(() => matchRoutes(routes.value, location.value, basename.value)); // console.log(matches.value)

  return vue.computed(() => matches.value && matches.value.reduceRight((outlet, {
    params,
    pathname,
    route
  }) => vue.h(Provide, {
    injectionKey: ROUTE_CONTEXT,
    value: {
      outlet,
      params: _objectSpread2({}, parentParams.value, {}, params),
      pathname: joinPaths([basename.value, pathname]),
      route
    }
  }, {
    default: () => [route.element]
  }), null));
};
const useRoutes = (partialRoutesValue, basename = '') => {
  const partialRoutes = useComputedCallback(partialRoutesValue);
  const routes = vue.computed(() => createRoutesFromArray(partialRoutes.value));
  return useRoutes_(routes, basename);
};

const createRoutesFromChildren = normalizedChildren => {
  const routes = [];
  const children = Array.isArray(normalizedChildren) ? normalizedChildren : normalizedChildren instanceof Object ? [vue.renderSlot(normalizedChildren, 'default')] : [];

  for (const element of children) {
    if (!vue.isVNode(element)) {
      continue;
    }

    if (element.type === 'template' || element.type === vue.Fragment) {
      routes.push(...createRoutesFromChildren(element.children));
      continue;
    }

    const {
      path,
      caseSensitive
    } = element.props || {};
    const route = {
      path: path || '/',
      caseSensitive: caseSensitive === true,
      element
    };

    if (element.children) {
      const childRoutes = createRoutesFromChildren(element.children);

      if (childRoutes.length) {
        route.children = childRoutes;
      }
    }

    routes.push(route);
  }

  return routes;
};

const Routes = vue.defineComponent({
  name: 'Routes',
  props: {
    basename: {
      default: '',
      required: false,
      type: String
    }
  },

  setup(props, {
    slots
  }) {
    const routes = vue.computed(() => createRoutesFromChildren([vue.renderSlot(slots, 'default')]));
    const vnode = useRoutes_(routes, () => props.basename);
    return () => vnode.value;
  }

});



var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BrowserRouter: BrowserRouter,
    Link: Link,
    MemoryRouter: MemoryRouter,
    NavLink: NavLink,
    Outlet: Outlet,
    Route: Route,
    Router: Router,
    Routes: Routes
});

const useBlocker = (blocker, whenValue = true) => {
  const locationContext = vue.inject(LOCATION_CONTEXT, null);
  assert(locationContext, `useBlocker() may be used only in the context of a <Router> component.`);
  const when = useComputedCallback(whenValue);
  const navigator = vue.toRef(locationContext, 'navigator');
  vue.watchEffect(onCleanup => {
    if (!when.value) {
      return;
    }

    const unblock = navigator.value.block(tx => {
      blocker(_objectSpread2({}, tx, {
        retry() {
          unblock();
          tx.retry();
        }

      }));
    });
    onCleanup(unblock);
  });
};

const useMatch = patternValue => {
  const pattern = useComputedCallback(patternValue);
  const context = useRouteContext();
  const pathname = vue.computed(() => context.value.pathname);
  const match = vue.computed(() => matchPath(pattern.value, pathname.value));
  return match;
};

const useParams = () => {
  const context = useRouteContext();
  return vue.computed(() => context.value.params);
};

const usePrompt = (messageValue, whenValue = true) => {
  const message = useComputedCallback(messageValue);
  useBlocker(tx => {
    if (window.confirm(message.value)) {
      tx.retry();
    }
  }, whenValue);
};

/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */

const createSearchParams = (init = '') => new URLSearchParams(typeof init === 'string' || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
  const value = init[key];
  return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
}, []));

const useSetSearchParams = () => {
  const navigate = useNavigate();
  return (nextInit, navigateOptions) => {
    navigate(`?${createSearchParams(nextInit)}`, navigateOptions);
  };
};

const useGetSearchParams = defaultInitValue => {
  const defaultInit = useComputedCallback(defaultInitValue);
  const defaultSearchParams = vue.computed(() => createSearchParams(defaultInit.value));
  const location = useLocation();
  const searchParams = vue.computed(() => createSearchParams(location.value.search));
  return vue.computed(() => {
    const defaultSearchParamsValue = defaultSearchParams.value;
    const searchParamsValue = createSearchParams(searchParams.value);

    for (const key of defaultSearchParamsValue.keys()) {
      if (!searchParamsValue.has(key)) {
        defaultSearchParamsValue.getAll(key).forEach(value => {
          searchParamsValue.append(key, value);
        });
      }
    }

    return searchParamsValue;
  });
};

const useSearchParams = defaultInit => {
  const searchParams = useGetSearchParams(defaultInit);
  const setSearchParams = useSetSearchParams();
  return [searchParams, setSearchParams];
};

const generatePath = (path, params = {}) => {
  return path.replace(/:(\w+)/g, (_, key) => {
    assert(params[key] != null, `Missing ":${key}" param`);
    return params[key];
  }).replace(/\/*\*$/, () => params['*'] == null ? '' : params['*'].replace(/^\/*/, '/'));
};

const install = app => {
  for (const key in components) {
    app.component(key, components[key]);
  }
};

Object.keys(history).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return history[k];
        }
    });
});
exports.BrowserRouter = BrowserRouter;
exports.LOCATION_CONTEXT = LOCATION_CONTEXT;
exports.Link = Link;
exports.MemoryRouter = MemoryRouter;
exports.NavLink = NavLink;
exports.Outlet = Outlet;
exports.ROUTE_CONTEXT = ROUTE_CONTEXT;
exports.Route = Route;
exports.Router = Router;
exports.Routes = Routes;
exports.createRoutesFromArray = createRoutesFromArray;
exports.createRoutesFromChildren = createRoutesFromChildren;
exports.generatePath = generatePath;
exports.install = install;
exports.matchPath = matchPath;
exports.matchRoutes = matchRoutes;
exports.resolvePath = resolvePath;
exports.useBlocker = useBlocker;
exports.useHref = useHref;
exports.useLocation = useLocation;
exports.useMatch = useMatch;
exports.useNavigate = useNavigate;
exports.useOutlet = useOutlet;
exports.useParams = useParams;
exports.usePrompt = usePrompt;
exports.useResolvedPath = useResolvedPath;
exports.useRoutes = useRoutes;
exports.useSearchParams = useSearchParams;
//# sourceMappingURL=index.js.map
