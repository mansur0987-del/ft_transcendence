import { defineComponent, provide, renderSlot, readonly, reactive, computed, watch, h, inject, toRef, isRef, toRefs, watchEffect, isVNode, Fragment } from 'vue';
import { Action, createBrowserHistory, parsePath, createPath, createMemoryHistory } from 'history';
export * from 'history';

const ROUTE_CONTEXT = Symbol('ROUTE_CONTEXT');
const LOCATION_CONTEXT = Symbol('LOCATION_CONTEXT');

const Router = defineComponent({
    name: 'Router',
    props: {
        location: { required: true, type: Object },
        navigator: { required: true, type: Object },
        action: {
            required: false,
            type: String,
            default: Action.Pop,
        },
        static: { required: false, type: Boolean, default: false },
    },
    setup(props, { slots }) {
        provide(LOCATION_CONTEXT, props);
        return () => renderSlot(slots, 'default');
    },
});

const useReducer = (reducer, initialState) => {
    const state = reactive(initialState);
    const dispatch = (...arg) => {
        reducer(state, ...arg);
    };
    return [readonly(state), dispatch];
};

const BrowserRouter = defineComponent({
    name: 'BrowserRouter',
    props: {
        window: {
            required: false,
            type: Object,
        },
    },
    setup(props, { slots }) {
        const history = computed(() => createBrowserHistory({
            window: props.window,
        }));
        const [state, dispatch] = useReducer((state, { action, location }) => {
            state.action = action;
            state.location = location;
        }, {
            action: history.value.action,
            location: history.value.location,
        });
        watch(history, (history) => history.listen(dispatch), {
            flush: 'sync',
            immediate: true,
        });
        return () => h(Router, {
            location: state.location,
            action: state.action,
            navigator: history.value,
        }, { default: slots.default });
    },
});

const throwError = (error) => {
    throw new Error(`[vue-router-dom] ${error}`);
};
function assert(condition, message) {
    if (!condition) {
        throwError(message);
    }
}

const useLocation = () => {
    const locationContext = inject(LOCATION_CONTEXT, null);
    assert(locationContext, `useLocation() may be used only in the context of a <Router> component.`);
    return toRef(locationContext, 'location');
};

const trimTrailingSlashes = (path) => path.replace(/\/+$/, '');
const normalizeSlashes = (path) => path.replace(/\/\/+/g, '/');
const joinPaths = (paths) => normalizeSlashes(paths.join('/'));
const splitPath = (path) => normalizeSlashes(path).split('/');
const resolvePathname = (toPathname, fromPathname) => {
    const segments = splitPath(trimTrailingSlashes(fromPathname));
    const relativeSegments = splitPath(toPathname);
    relativeSegments.forEach((segment) => {
        if (segment === '..') {
            // Keep the root "" segment so the pathname starts at /
            if (segments.length > 1)
                segments.pop();
        }
        else if (segment !== '.') {
            segments.push(segment);
        }
    });
    return segments.length > 1 ? joinPaths(segments) : '/';
};
const resolvePath = (to, fromPathname = '/') => {
    const { pathname: toPathname, search = '', hash = '' } = typeof to === 'string' ? parsePath(to) : to;
    const pathname = toPathname
        ? resolvePathname(toPathname, toPathname.startsWith('/') ? '/' : fromPathname)
        : fromPathname;
    return { pathname, search, hash };
};

const useRouteContext = () => inject(ROUTE_CONTEXT, computed(() => ({
    pathname: '',
    outlet: null,
    params: {},
    route: null,
})));
const useOutlet = () => {
    const context = useRouteContext();
    return computed(() => context.value.outlet);
};

const useNavigate = () => {
    const locationContext = inject(LOCATION_CONTEXT, null);
    assert(locationContext, `useNavigate() may be used only in the context of a <Router> component.`);
    const navigator = toRef(locationContext, 'navigator');
    const context = useRouteContext();
    const pathname = computed(() => context.value.pathname);
    const navigate = (to, { state, replace = false, } = {}) => {
        const navigatorValue = navigator.value;
        if (typeof to === 'number') {
            return navigatorValue.go(to);
        }
        const path = resolvePath(to, pathname.value);
        (replace ? navigatorValue.replace : navigatorValue.push)(path, state);
    };
    return navigate;
};

const useComputedCallback = (value) => value instanceof Function
    ? computed(value)
    : isRef(value)
        ? value
        : computed(() => value);

const useResolvedPath = (toValue) => {
    const to = useComputedCallback(toValue);
    const context = useRouteContext();
    const pathname = computed(() => context.value.pathname);
    return computed(() => resolvePath(to.value, pathname.value));
};

const useHref = (toValue) => {
    const locationContext = inject(LOCATION_CONTEXT, null);
    assert(locationContext, `useHref() may be used only in the context of a <Router> component.`);
    const navigator = toRef(locationContext, 'navigator');
    const to = useComputedCallback(toValue);
    const path = useResolvedPath(to);
    return computed(() => navigator.value.createHref(path.value));
};

const linkProps = {
    replace: {
        default: false,
        required: false,
        type: Boolean,
    },
    tag: {
        default: 'a',
        required: false,
        type: String,
    },
    to: { default: '', required: true, type: [String, Object] },
    state: {
        default: undefined,
        required: false,
        type: Object,
    },
};
const Link = defineComponent({
    name: 'Link',
    props: linkProps,
    emits: { click: null },
    setup(props, { slots, emit }) {
        const { to, replace } = toRefs(props);
        const href = useHref(to);
        const location = useLocation();
        const path = useResolvedPath(to);
        const navigate = useNavigate();
        const handleClick = (event) => {
            emit('click', event);
            event.stopPropagation();
            event.preventDefault();
            const pathValue = path.value;
            // If the URL hasn't changed, replace instead of push.
            const replaceValue = !!replace.value || createPath(location.value) === createPath(pathValue);
            navigate(pathValue, {
                replace: replaceValue,
                state: props.state,
            });
        };
        return () => h(props.tag, {
            href: href.value,
            onClick: handleClick,
        }, { default: slots.default });
    },
});

const MemoryRouter = defineComponent({
    name: 'MemoryRouter',
    props: {
        initialEntries: {
            required: false,
            type: Array,
        },
        initialIndex: { required: false, type: Number },
    },
    setup(props, { slots }) {
        const history = computed(() => createMemoryHistory({
            initialEntries: props.initialEntries,
            initialIndex: props.initialIndex,
        }));
        const [state, dispatch] = useReducer((state, { action, location }) => {
            state.action = action;
            state.location = location;
        }, {
            action: history.value.action,
            location: history.value.location,
        });
        watch(history, (history) => history.listen(dispatch), {
            flush: 'sync',
            immediate: true,
        });
        return () => h(Router, {
            location: state.location,
            action: state.action,
            navigator: history.value,
        }, { default: slots.default });
    },
});

const useCaseSensitive = (caseSensitiveValue, stringValue) => {
    const caseSensitive = useComputedCallback(caseSensitiveValue);
    const string = useComputedCallback(stringValue);
    return computed(() => {
        const stringValue = string.value;
        return caseSensitive.value ? stringValue : stringValue.toLowerCase();
    });
};
const NavLink = defineComponent({
    name: 'NavLink',
    props: {
        activeClassName: {
            default: '',
            required: false,
            type: String,
        },
        activeStyle: {
            default: () => ({}),
            required: false,
            type: Object,
        },
        caseSensitive: {
            default: false,
            required: false,
            type: Boolean,
        },
        end: {
            default: false,
            required: false,
            type: Boolean,
        },
        ariaCurrent: { default: 'page', type: String, required: false },
        ...linkProps,
    },
    setup(props, { slots }) {
        const location = useLocation();
        const { to, caseSensitive } = toRefs(props);
        const path = useResolvedPath(to);
        const locationPathname = computed(() => location.value.pathname);
        const toPathname = computed(() => path.value.pathname);
        const caseSensitiveLocationPathname = useCaseSensitive(caseSensitive, locationPathname);
        const caseSensitiveToPathname = useCaseSensitive(caseSensitive, toPathname);
        const isActive = computed(() => {
            const locationPathname = caseSensitiveLocationPathname.value;
            const toPathname = caseSensitiveToPathname.value;
            return props.end
                ? locationPathname === toPathname
                : locationPathname.startsWith(toPathname);
        });
        const ariaCurrent = computed(() => isActive.value ? props.ariaCurrent : undefined);
        const className = computed(() => isActive.value && props.activeClassName);
        const style = computed(() => isActive.value && props.activeStyle);
        return () => h(Link, {
            style: style.value,
            class: className.value,
            to: props.to,
            ariaCurrent: ariaCurrent.value,
        }, { default: slots.default });
    },
});

const Outlet = defineComponent({
    name: 'Outlet',
    setup() {
        const outletElement = useOutlet();
        return () => outletElement.value;
    },
});

const Route = defineComponent({
    name: 'Route',
    props: {
        path: {
            default: '',
            required: false,
            type: String,
        },
        caseSensitive: {
            default: false,
            required: false,
            type: Boolean,
        },
        element: {
            default: () => h(Outlet),
            required: false,
            type: Object,
        },
    },
    setup(props, { slots }) {
        return () => renderSlot(slots, 'element', undefined, () => [props.element]);
    },
});

const compilePath = (path, caseSensitive, end) => {
    const keys = [];
    let source = '^(' +
        path
            .replace(/^\/*/, '/') // Make sure it has a leading /
            .replace(/\/?\*?$/, '') // Ignore trailing / and /*, we'll handle it below
            .replace(/[\\.*+^$?{}|()[\]]/g, '\\$&') // Escape special regex chars
            .replace(/:(\w+)/g, (_, key) => {
            keys.push(key);
            return '([^\\/]+)';
        }) +
        ')';
    if (path.endsWith('*')) {
        if (path.endsWith('/*')) {
            source += '\\/?'; // Don't include the / in params['*']
        }
        keys.push('*');
        source += '(.*)';
    }
    else if (end) {
        source += '\\/?';
    }
    if (end)
        source += '$';
    const flags = caseSensitive ? undefined : 'i';
    const matcher = new RegExp(source, flags);
    return [matcher, keys];
};
const safelyDecodeURIComponent = (value, paramName) => {
    try {
        return decodeURIComponent(value.replace(/\+/g, ' '));
    }
    catch (error) {
        assert(false, `The value for the URL param "${paramName}" will not be decoded because` +
            ` the string "${value}" is a malformed URL segment. This is probably` +
            ` due to a bad percent encoding (${error}).`);
    }
};
const matchPath = (pattern, pathname) => {
    if (typeof pattern === 'string') {
        pattern = { path: pattern };
    }
    const { path, caseSensitive = false, end = true } = pattern;
    const [matcher, paramNames] = compilePath(path, caseSensitive, end);
    const match = pathname.match(matcher);
    if (!match)
        return null;
    const matchedPathname = match[1];
    const values = match.slice(2);
    const params = paramNames.reduce((memo, paramName, index) => {
        memo[paramName] = safelyDecodeURIComponent(values[index], paramName);
        return memo;
    }, {});
    return { path, pathname: matchedPathname, params };
};

const paramRe = /^:\w+$/;
const dynamicSegmentValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === '*';
function matchRouteBranch(branch, pathname) {
    const routes = branch[1];
    let matchedPathname = '/';
    let matchedParams = {};
    const matches = [];
    for (let i = 0; i < routes.length; ++i) {
        const route = routes[i];
        const remainingPathname = matchedPathname === '/'
            ? pathname
            : pathname.slice(matchedPathname.length) || '/';
        const routeMatch = matchPath({
            path: route.path,
            caseSensitive: route.caseSensitive,
            end: i === routes.length - 1,
        }, remainingPathname);
        if (!routeMatch)
            return null;
        matchedPathname = joinPaths([matchedPathname, routeMatch.pathname]);
        matchedParams = { ...matchedParams, ...routeMatch.params };
        matches.push({
            route,
            pathname: matchedPathname,
            params: matchedParams,
        });
    }
    return matches;
}
function compareIndexes(a, b) {
    const siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
    return siblings
        ? // If two routes are siblings, we should try to match the earlier sibling
            // first. This allows people to have fine-grained control over the matching
            // behavior by simply putting routes with identical paths in the order they
            // want them tried.
            a[a.length - 1] - b[b.length - 1]
        : // Otherwise, it doesn't really make sense to rank non-siblings by index,
            // so they sort equally.
            0;
}
function stableSort(array, compareItems) {
    // This copy lets us get the original index of an item so we can preserve the
    // original ordering in the case that they sort equally.
    const copy = array.slice(0);
    array.sort((a, b) => compareItems(a, b) || copy.indexOf(a) - copy.indexOf(b));
}
function computeScore(path) {
    const segments = path.split('/');
    let initialScore = segments.length;
    if (segments.some(isSplat)) {
        initialScore += splatPenalty;
    }
    return segments
        .filter((s) => !isSplat(s))
        .reduce((score, segment) => score +
        (paramRe.test(segment)
            ? dynamicSegmentValue
            : segment === ''
                ? emptySegmentValue
                : staticSegmentValue), initialScore);
}
function rankRouteBranches(branches) {
    const pathScores = branches.reduce((memo, [path]) => {
        memo[path] = computeScore(path);
        return memo;
    }, {});
    // Sorting is stable in modern browsers, but we still support IE 11, so we
    // need this little helper.
    stableSort(branches, (a, b) => {
        const [aPath, , aIndexes] = a;
        const aScore = pathScores[aPath];
        const [bPath, , bIndexes] = b;
        const bScore = pathScores[bPath];
        return aScore !== bScore
            ? bScore - aScore // Higher score first
            : compareIndexes(aIndexes, bIndexes);
    });
}
function flattenRoutes(routes, branches = [], parentPath = '', parentRoutes = [], parentIndexes = []) {
    routes.forEach((route, index) => {
        const path = joinPaths([parentPath, route.path]);
        const routes = parentRoutes.concat(route);
        const indexes = parentIndexes.concat(index);
        // Add the children before adding this route to the array so we traverse the
        // route tree depth-first and child routes appear before their parents in
        // the "flattened" version.
        if (route.children) {
            flattenRoutes(route.children, branches, path, routes, indexes);
        }
        branches.push([path, routes, indexes]);
    });
    return branches;
}
const matchRoutes = (routes, location, basename = '') => {
    if (typeof location === 'string') {
        location = parsePath(location);
    }
    let pathname = location.pathname || '/';
    if (basename) {
        const base = basename.replace(/^\/*/, '/').replace(/\/+$/, '');
        if (pathname.startsWith(base)) {
            pathname = pathname === base ? '/' : pathname.slice(base.length);
        }
        else {
            // Pathname does not start with the basename, no match.
            return null;
        }
    }
    const branches = flattenRoutes(routes);
    rankRouteBranches(branches);
    let matches = null;
    for (let i = 0; matches == null && i < branches.length; i++) {
        // TODO: Match on search, state too?
        matches = matchRouteBranch(branches[i], pathname);
    }
    return matches;
};

const createRoutesFromArray = (partialRouteObjects) => {
    return partialRouteObjects.map((partialRoute) => {
        const route = {
            path: partialRoute.path || '/',
            caseSensitive: partialRoute.caseSensitive === true,
            element: partialRoute.element || h(Outlet),
        };
        if (partialRoute.children) {
            route.children = createRoutesFromArray(partialRoute.children);
        }
        return route;
    });
};

const Provide = defineComponent({
    props: {
        injectionKey: { required: true, type: [String, Symbol] },
        value: null,
    },
    setup(props, { slots }) {
        provide(props.injectionKey, computed(() => props.value));
        return () => renderSlot(slots, 'default');
    },
});
const useJoinPaths = (pathsValue) => {
    const paths = useComputedCallback(pathsValue);
    return computed(() => joinPaths(paths.value));
};
const useRoutes_ = (routesValue, basenameValue = '') => {
    const routes = useComputedCallback(routesValue);
    const defaultBasename = useComputedCallback(basenameValue);
    const context = useRouteContext();
    const parentRoute = computed(() => context.value.route);
    const parentPathname = computed(() => context.value.pathname);
    const parentParams = computed(() => context.value.params);
    const location = useLocation();
    const parentPath = computed(() => parentRoute.value && parentRoute.value.path);
    watchEffect(() => {
        const parentRouteValue = parentRoute.value;
        if (parentRouteValue && !parentRouteValue.path.endsWith('*')) {
            console.warn(`You rendered descendant <Routes> (or called \`useRoutes\`) at "${parentPathname.value}"` +
                ` (under <Route path="${parentPath.value}">) but the parent route path has no trailing "*".` +
                ` This means if you navigate deeper, the parent won't match anymore and therefore` +
                ` the child routes will never render.` +
                `\n\n` +
                `Please change the parent <Route path="${parentPath.value}"> to <Route path="${parentPath.value}/*">.`);
        }
    });
    const joinedPaths = useJoinPaths(() => [
        parentPathname.value,
        defaultBasename.value,
    ]);
    const basename = computed(() => defaultBasename.value ? joinedPaths.value : parentPathname.value);
    const matches = computed(() => matchRoutes(routes.value, location.value, basename.value));
    // console.log(matches.value)
    return computed(() => matches.value &&
        matches.value.reduceRight((outlet, { params, pathname, route }) => h(Provide, {
            injectionKey: ROUTE_CONTEXT,
            value: {
                outlet,
                params: { ...parentParams.value, ...params },
                pathname: joinPaths([basename.value, pathname]),
                route,
            },
        }, { default: () => [route.element] }), null));
};
const useRoutes = (partialRoutesValue, basename = '') => {
    const partialRoutes = useComputedCallback(partialRoutesValue);
    const routes = computed(() => createRoutesFromArray(partialRoutes.value));
    return useRoutes_(routes, basename);
};

const createRoutesFromChildren = (normalizedChildren) => {
    const routes = [];
    const children = Array.isArray(normalizedChildren)
        ? normalizedChildren
        : normalizedChildren instanceof Object
            ? [renderSlot(normalizedChildren, 'default')]
            : [];
    for (const element of children) {
        if (!isVNode(element)) {
            continue;
        }
        if (element.type === 'template' || element.type === Fragment) {
            routes.push(...createRoutesFromChildren(element.children));
            continue;
        }
        const { path, caseSensitive } = element.props || {};
        const route = {
            path: path || '/',
            caseSensitive: caseSensitive === true,
            element,
        };
        if (element.children) {
            const childRoutes = createRoutesFromChildren(element.children);
            if (childRoutes.length) {
                route.children = childRoutes;
            }
        }
        routes.push(route);
    }
    return routes;
};

const Routes = defineComponent({
    name: 'Routes',
    props: { basename: { default: '', required: false, type: String } },
    setup(props, { slots }) {
        const routes = computed(() => createRoutesFromChildren([renderSlot(slots, 'default')]));
        const vnode = useRoutes_(routes, () => props.basename);
        return () => vnode.value;
    },
});



var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BrowserRouter: BrowserRouter,
    Link: Link,
    MemoryRouter: MemoryRouter,
    NavLink: NavLink,
    Outlet: Outlet,
    Route: Route,
    Router: Router,
    Routes: Routes
});

const useBlocker = (blocker, whenValue = true) => {
    const locationContext = inject(LOCATION_CONTEXT, null);
    assert(locationContext, `useBlocker() may be used only in the context of a <Router> component.`);
    const when = useComputedCallback(whenValue);
    const navigator = toRef(locationContext, 'navigator');
    watchEffect((onCleanup) => {
        if (!when.value) {
            return;
        }
        const unblock = navigator.value.block((tx) => {
            blocker({
                ...tx,
                retry() {
                    unblock();
                    tx.retry();
                },
            });
        });
        onCleanup(unblock);
    });
};

const useMatch = (patternValue) => {
    const pattern = useComputedCallback(patternValue);
    const context = useRouteContext();
    const pathname = computed(() => context.value.pathname);
    const match = computed(() => matchPath(pattern.value, pathname.value));
    return match;
};

const useParams = () => {
    const context = useRouteContext();
    return computed(() => context.value.params);
};

const usePrompt = (messageValue, whenValue = true) => {
    const message = useComputedCallback(messageValue);
    useBlocker((tx) => {
        if (window.confirm(message.value)) {
            tx.retry();
        }
    }, whenValue);
};

/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */
const createSearchParams = (init = '') => new URLSearchParams(typeof init === 'string' ||
    Array.isArray(init) ||
    init instanceof URLSearchParams
    ? init
    : Object.keys(init).reduce((memo, key) => {
        const value = init[key];
        return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
    }, []));
const useSetSearchParams = () => {
    const navigate = useNavigate();
    return (nextInit, navigateOptions) => {
        navigate(`?${createSearchParams(nextInit)}`, navigateOptions);
    };
};
const useGetSearchParams = (defaultInitValue) => {
    const defaultInit = useComputedCallback(defaultInitValue);
    const defaultSearchParams = computed(() => createSearchParams(defaultInit.value));
    const location = useLocation();
    const searchParams = computed(() => createSearchParams(location.value.search));
    return computed(() => {
        const defaultSearchParamsValue = defaultSearchParams.value;
        const searchParamsValue = createSearchParams(searchParams.value);
        for (const key of defaultSearchParamsValue.keys()) {
            if (!searchParamsValue.has(key)) {
                defaultSearchParamsValue.getAll(key).forEach((value) => {
                    searchParamsValue.append(key, value);
                });
            }
        }
        return searchParamsValue;
    });
};
const useSearchParams = (defaultInit) => {
    const searchParams = useGetSearchParams(defaultInit);
    const setSearchParams = useSetSearchParams();
    return [searchParams, setSearchParams];
};

const generatePath = (path, params = {}) => {
    return path
        .replace(/:(\w+)/g, (_, key) => {
        assert(params[key] != null, `Missing ":${key}" param`);
        return params[key];
    })
        .replace(/\/*\*$/, () => params['*'] == null ? '' : params['*'].replace(/^\/*/, '/'));
};

const install = (app) => {
    for (const key in components) {
        app.component(key, components[key]);
    }
};

export { BrowserRouter, LOCATION_CONTEXT, Link, MemoryRouter, NavLink, Outlet, ROUTE_CONTEXT, Route, Router, Routes, createRoutesFromArray, createRoutesFromChildren, generatePath, install, matchPath, matchRoutes, resolvePath, useBlocker, useHref, useLocation, useMatch, useNavigate, useOutlet, useParams, usePrompt, useResolvedPath, useRoutes, useSearchParams };
//# sourceMappingURL=index.js.map
