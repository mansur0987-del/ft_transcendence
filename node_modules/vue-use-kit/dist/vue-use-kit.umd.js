/**
  * Name: Vue use kit
  * Author: Salvatore Tedde <microcipcip@gmail.com>
  * Website: https://github.com/microcipcip/vue-use-kit 
  * Date: 26/04/2020 
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@vue/composition-api')) :
  typeof define === 'function' && define.amd ? define(['exports', '@vue/composition-api'], factory) :
  (factory((global.vueUseKit = {}),global.vueCompositionApi));
}(this, (function (exports,compositionApi) { 'use strict';

  var compositionApi__default = 'default' in compositionApi ? compositionApi['default'] : compositionApi;

  function getQuery(min, max) {
      if (min === void 0) { min = 0; }
      if (max === void 0) { max = 0; }
      if (!min && !max) {
          throw new Error("Please specify at least one value, either 'min' or 'max'");
      }
      else if (min && !max) {
          return "only screen and (min-width: " + min + "px)";
      }
      else if (!min && max) {
          return "only screen and (max-width: " + (max - 1) + "px)";
      }
      else {
          return "only screen and (min-width: " + min + "px) and (max-width: " + (max - 1) + "px)";
      }
  }

  var defaultEvents = ['mousedown', 'touchstart'];
  function useClickAway(elRef, callback, events) {
      if (events === void 0) { events = defaultEvents; }
      var handler = function (e) {
          if (elRef.value && !elRef.value.contains(e.target)) {
              callback(e);
          }
      };
      compositionApi.onMounted(function () {
          events.forEach(function (evtName) { return document.addEventListener(evtName, handler); });
      });
      compositionApi.onUnmounted(function () {
          events.forEach(function (evtName) { return document.removeEventListener(evtName, handler); });
      });
  }

  function useFullscreen(elRef) {
      var isFullscreen = compositionApi.ref(false);
      var handleFullscreenChange = function () {
          if (!isFullscreen.value)
              return;
          var isCurrentlyFullscreen = !!document.fullscreenElement;
          isFullscreen.value = isCurrentlyFullscreen;
      };
      var startTracking = function () {
          document.addEventListener('fullscreenchange', handleFullscreenChange);
      };
      var stopTracking = function () {
          document.removeEventListener('fullscreenchange', handleFullscreenChange);
      };
      var start = function () {
          if (!elRef.value)
              return;
          if (isFullscreen.value)
              return;
          elRef.value.requestFullscreen().then(function () {
              isFullscreen.value = true;
              startTracking();
          });
      };
      var stop = function () {
          if (!isFullscreen.value)
              return;
          document.exitFullscreen().then(function () {
              isFullscreen.value = false;
              stopTracking();
          });
      };
      compositionApi.onUnmounted(stopTracking);
      return { isFullscreen: isFullscreen, start: start, stop: stop };
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
              t[p[i]] = s[p[i]];
      return t;
  }

  function __awaiter(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  var defaultOpts = {
      enableHighAccuracy: false,
      timeout: Infinity,
      maximumAge: 0
  };
  function useGeolocation(options, runOnMount) {
      if (options === void 0) { options = {}; }
      if (runOnMount === void 0) { runOnMount = true; }
      options = Object.assign({}, defaultOpts, options);
      // Note: surprisingly the watchId can be 0 (not positive) so
      // we have to check if watchId !== null every time
      var watchId = null;
      var geoInitData = {
          loading: false,
          accuracy: null,
          altitude: null,
          altitudeAccuracy: null,
          heading: null,
          latitude: null,
          longitude: null,
          speed: null,
          timestamp: null
      };
      var isTracking = compositionApi.ref(false);
      var geo = compositionApi.ref(__assign({}, geoInitData));
      var onEventError = function (error) {
          if (watchId === null)
              return;
          geo.value.loading = false;
          geo.value.error = {
              code: error.code,
              message: error.message
          };
          isTracking.value = false;
      };
      var handleGeolocation = function (_a) {
          var coords = _a.coords, timestamp = _a.timestamp;
          geo.value = {
              loading: false,
              accuracy: coords.accuracy,
              altitude: coords.altitude,
              altitudeAccuracy: coords.altitudeAccuracy,
              heading: coords.heading,
              latitude: coords.latitude,
              longitude: coords.longitude,
              speed: coords.speed,
              timestamp: timestamp
          };
          isTracking.value = true;
      };
      var start = function () {
          if (watchId !== null)
              return;
          geo.value.loading = true;
          geo.value.timestamp = Date.now();
          navigator.geolocation.getCurrentPosition(handleGeolocation, onEventError, options);
          watchId = navigator.geolocation.watchPosition(handleGeolocation, onEventError, options);
      };
      var stop = function () {
          if (watchId === null)
              return;
          navigator.geolocation.clearWatch(watchId);
          watchId = null;
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { isTracking: isTracking, geo: geo, start: start, stop: stop };
  }

  function useHover(elRef) {
      var isHovered = compositionApi.ref(false);
      var mouseEnterHandler = function () {
          isHovered.value = true;
      };
      var mouseLeaveHandler = function () {
          isHovered.value = false;
      };
      compositionApi.onMounted(function () {
          if (!elRef.value)
              return;
          elRef.value.addEventListener('mouseenter', mouseEnterHandler);
          elRef.value.addEventListener('mouseleave', mouseLeaveHandler);
      });
      compositionApi.onUnmounted(function () {
          if (!elRef.value)
              return;
          elRef.value.removeEventListener('mouseenter', mouseEnterHandler);
          elRef.value.removeEventListener('mouseleave', mouseLeaveHandler);
      });
      return isHovered;
  }

  /* eslint-disable no-undefined,no-param-reassign,no-shadow */

  /**
   * Throttle execution of a function. Especially useful for rate limiting
   * execution of handlers on events like resize and scroll.
   *
   * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
   * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
   *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
   *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
   *                                    the internal counter is reset)
   * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
   *                                    to `callback` when the throttled-function is executed.
   * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
   *                                    schedule `callback` to execute after `delay` ms.
   *
   * @return {Function}  A new, throttled, function.
   */
  function throttle (delay, noTrailing, callback, debounceMode) {
    /*
     * After wrapper has stopped being called, this timeout ensures that
     * `callback` is executed at the proper times in `throttle` and `end`
     * debounce modes.
     */
    var timeoutID;
    var cancelled = false; // Keep track of the last time `callback` was executed.

    var lastExec = 0; // Function to clear existing timeout

    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    } // Function to cancel next exec


    function cancel() {
      clearExistingTimeout();
      cancelled = true;
    } // `noTrailing` defaults to falsy.


    if (typeof noTrailing !== 'boolean') {
      debounceMode = callback;
      callback = noTrailing;
      noTrailing = undefined;
    }
    /*
     * The `wrapper` function encapsulates all of the throttling / debouncing
     * functionality and when executed will limit the rate at which `callback`
     * is executed.
     */


    function wrapper() {
      var self = this;
      var elapsed = Date.now() - lastExec;
      var args = arguments;

      if (cancelled) {
        return;
      } // Execute `callback` and update the `lastExec` timestamp.


      function exec() {
        lastExec = Date.now();
        callback.apply(self, args);
      }
      /*
       * If `debounceMode` is true (at begin) this is used to clear the flag
       * to allow future `callback` executions.
       */


      function clear() {
        timeoutID = undefined;
      }

      if (debounceMode && !timeoutID) {
        /*
         * Since `wrapper` is being called for the first time and
         * `debounceMode` is true (at begin), execute `callback`.
         */
        exec();
      }

      clearExistingTimeout();

      if (debounceMode === undefined && elapsed > delay) {
        /*
         * In throttle mode, if `delay` time has been exceeded, execute
         * `callback`.
         */
        exec();
      } else if (noTrailing !== true) {
        /*
         * In trailing throttle mode, since `delay` time has not been
         * exceeded, schedule `callback` to execute `delay` ms after most
         * recent execution.
         *
         * If `debounceMode` is true (at begin), schedule `clear` to execute
         * after `delay` ms.
         *
         * If `debounceMode` is false (at end), schedule `callback` to
         * execute after `delay` ms.
         */
        timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
      }
    }

    wrapper.cancel = cancel; // Return the wrapper function.

    return wrapper;
  }

  var idleEventsList = [
      'mousemove',
      'mousedown',
      'resize',
      'keydown',
      'touchstart',
      'wheel'
  ];
  var oneMinute = 60e3;
  function useIdle(ms, events, runOnMount) {
      if (ms === void 0) { ms = oneMinute; }
      if (events === void 0) { events = idleEventsList; }
      if (runOnMount === void 0) { runOnMount = true; }
      var timeout = null;
      var isIdle = compositionApi.ref(false);
      var isTracking = compositionApi.ref(false);
      var handleChange = throttle(50, function () {
          isIdle.value = false;
          if (timeout)
              clearTimeout(timeout);
          timeout = setTimeout(function () {
              isIdle.value = true;
          }, ms);
      });
      var handleVisibility = function () {
          if (!document.hidden)
              return;
          handleChange();
      };
      var start = function () {
          if (isTracking.value)
              return;
          events.forEach(function (evtName) { return document.addEventListener(evtName, handleChange); });
          document.addEventListener('visibilitychange', handleVisibility);
          // Initialize it since the events above may not run immediately
          handleChange();
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          events.forEach(function (evtName) {
              return document.removeEventListener(evtName, handleChange);
          });
          document.removeEventListener('visibilitychange', handleVisibility);
          // Stop timer if it is still running
          if (timeout)
              clearTimeout(timeout);
          // Restore initial status
          timeout = null;
          isIdle.value = false;
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { isIdle: isIdle, isTracking: isTracking, start: start, stop: stop };
  }

  var errorMsg = 'IntersectionObserver is not supported, please install a polyfill';
  function useIntersection(elRef, options, runOnMount) {
      if (options === void 0) { options = {}; }
      if (runOnMount === void 0) { runOnMount = true; }
      var observedEntry = compositionApi.ref(null);
      var handleObserver = function (entries) {
          observedEntry.value = entries[0];
      };
      var observer = null;
      var start = function () {
          if (!('IntersectionObserver' in window))
              throw new Error(errorMsg);
          // Do not start if the observer is already initialized
          // or the elRef does not exist
          if (observer || !elRef.value)
              return;
          observer = new IntersectionObserver(handleObserver, options);
          observer.observe(elRef.value);
      };
      var stop = function () {
          if (!observer)
              return;
          observer.disconnect();
          observer = null;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { observedEntry: observedEntry, start: start, stop: stop };
  }

  function useKey(filter, callback, runOnMount) {
      if (callback === void 0) { callback = function () { return ""; }; }
      if (runOnMount === void 0) { runOnMount = true; }
      var isTracking = compositionApi.ref(false);
      var isPressed = compositionApi.ref(false);
      var getFilter = function () {
          if (typeof filter === 'function')
              return filter;
          return function (event) { return event.key === filter; };
      };
      var handleKeyDown = function (event) {
          var filterFn = getFilter();
          if (!filterFn(event))
              return;
          isPressed.value = true;
          callback(event);
      };
      var handleKeyUp = function (event) {
          var filterFn = getFilter();
          if (!filterFn(event))
              return;
          isPressed.value = false;
          callback(event);
      };
      var start = function () {
          if (isTracking.value)
              return;
          document.addEventListener('keydown', handleKeyDown);
          document.addEventListener('keyup', handleKeyUp);
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          document.removeEventListener('keydown', handleKeyDown);
          document.removeEventListener('keyup', handleKeyUp);
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { isPressed: isPressed, isTracking: isTracking, start: start, stop: stop };
  }

  var isClient = typeof window === 'object';
  var checkType = function (typeToCheck) {
      return Object.prototype.toString.call(typeToCheck);
  };
  var isString = function (varToCheck) {
      return checkType(varToCheck) === '[object String]';
  };
  var isNull = function (varToCheck) {
      return checkType(varToCheck) === '[object Null]';
  };
  var isUndefined = function (varToCheck) {
      return checkType(varToCheck) === '[object Undefined]';
  };
  var isNullOrUndefined = function (varToCheck) {
      return isNull(varToCheck) || isUndefined(varToCheck);
  };
  // The history methods 'pushState' and 'replaceState' by default do not fire an event
  // unless it is coming from user interaction with the browser navigation bar,
  // so we are adding a patch to make them detectable
  var isPatched = false;
  var patchHistoryMethodsOnce = function () {
      if (isPatched)
          return;
      var methods = ['pushState', 'replaceState'];
      methods.forEach(function (method) {
          var original = history[method];
          history[method] = function (state) {
              // eslint-disable-next-line prefer-rest-params
              var result = original.apply(this, arguments);
              var event = new Event(method.toLowerCase());
              event.state = state;
              window.dispatchEvent(event);
              return result;
          };
      });
      isPatched = true;
  };
  var normalizeEntriesData = function (data) {
      return data.reduce(function (acc, _a) {
          var key = _a[0], val = _a[1];
          acc[key] = val;
          return acc;
      }, {});
  };
  var createSerializer = function (serializer) {
      return serializer || JSON.stringify;
  };
  var createDeserializer = function (deserializer) {
      return deserializer || JSON.parse;
  };
  var fallbackToString = function (val) { return (isString(val) ? val : String(val)); };
  var trySerialize = function (val, serializer, shouldSerialize) {
      if (!shouldSerialize)
          return fallbackToString(val);
      try {
          return fallbackToString(serializer(val));
      }
      catch (error) {
          return fallbackToString(val);
      }
  };
  var tryDeserialize = function (val, deserializer, shouldDeserialize) {
      if (!shouldDeserialize)
          return val;
      try {
          return deserializer(val);
      }
      catch (error) {
          return val;
      }
  };

  function useLocation(runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var buildState = function (trigger) {
          var state = history.state, length = history.length;
          var hash = location.hash, host = location.host, hostname = location.hostname, href = location.href, origin = location.origin, pathname = location.pathname, port = location.port, protocol = location.protocol, search = location.search;
          return {
              trigger: trigger,
              state: state,
              length: length,
              hash: hash,
              host: host,
              hostname: hostname,
              href: href,
              origin: origin,
              pathname: pathname,
              port: port,
              protocol: protocol,
              search: search
          };
      };
      var isTracking = compositionApi.ref(false);
      var locationState = compositionApi.ref(buildState('load'));
      var popState = function () { return (locationState.value = buildState('popstate')); };
      var pushState = function () { return (locationState.value = buildState('pushstate')); };
      var replaceState = function () { return (locationState.value = buildState('replacestate')); };
      var start = function () {
          if (isTracking.value)
              return;
          patchHistoryMethodsOnce();
          locationState.value = buildState('start');
          window.addEventListener('popstate', popState);
          window.addEventListener('pushstate', pushState);
          window.addEventListener('replacestate', replaceState);
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          window.removeEventListener('popstate', popState);
          window.removeEventListener('pushstate', pushState);
          window.removeEventListener('replacestate', replaceState);
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { locationState: locationState, isTracking: isTracking, start: start, stop: stop };
  }

  function useMedia(query, defaultState) {
      if (defaultState === void 0) { defaultState = false; }
      var mql;
      var matches = compositionApi.ref(defaultState);
      var updateMatchValue = function () { return (matches.value = mql.matches); };
      compositionApi.onMounted(function () {
          mql = window.matchMedia(query);
          mql.addListener(updateMatchValue);
          updateMatchValue();
      });
      compositionApi.onUnmounted(function () {
          mql.removeListener(updateMatchValue);
      });
      return matches;
  }

  function useMediaDevices(runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var devicesState = compositionApi.ref([]);
      var isTracking = compositionApi.ref(false);
      var isTracked = compositionApi.ref(false);
      var deviceMap = function (_a) {
          var deviceId = _a.deviceId, groupId = _a.groupId, kind = _a.kind, label = _a.label;
          return ({
              deviceId: deviceId,
              groupId: groupId,
              kind: kind,
              label: label
          });
      };
      var handleDeviceChange = function () {
          navigator.mediaDevices
              .enumerateDevices()
              .then(function (deviceList) {
              if (!isTracking.value)
                  return;
              isTracked.value = true;
              devicesState.value = deviceList.map(deviceMap);
          })
              .catch(function () {
              isTracked.value = false;
          });
      };
      var start = function () {
          if (isTracking.value)
              return;
          handleDeviceChange();
          navigator.mediaDevices.addEventListener('devicechange', handleDeviceChange);
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          navigator.mediaDevices.removeEventListener('devicechange', handleDeviceChange);
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { devicesState: devicesState, isTracking: isTracking, isTracked: isTracked, start: start, stop: stop };
  }

  function useMouse() {
      var docX = compositionApi.ref(0);
      var docY = compositionApi.ref(0);
      var mouseMoveHandler = function (e) {
          docX.value = e.pageX;
          docY.value = e.pageY;
      };
      compositionApi.onMounted(function () {
          document.addEventListener('mousemove', mouseMoveHandler);
      });
      compositionApi.onUnmounted(function () {
          document.removeEventListener('mousemove', mouseMoveHandler);
      });
      return {
          docX: docX,
          docY: docY
      };
  }

  function useMouseElement(elRef) {
      var docX = compositionApi.ref(0);
      var docY = compositionApi.ref(0);
      var elX = compositionApi.ref(0);
      var elY = compositionApi.ref(0);
      var elInfoX = compositionApi.ref(0);
      var elInfoY = compositionApi.ref(0);
      var elInfoW = compositionApi.ref(0);
      var elInfoH = compositionApi.ref(0);
      var mouseMoveHandler = function (e) {
          if (!elRef.value)
              return;
          docX.value = e.pageX;
          docY.value = e.pageY;
          var _a = elRef.value.getBoundingClientRect(), left = _a.left, top = _a.top, height = _a.height, width = _a.width;
          elInfoX.value = left + window.pageXOffset;
          elInfoY.value = top + window.pageYOffset;
          elInfoW.value = width;
          elInfoH.value = height;
          elX.value = e.pageX - elInfoX.value;
          elY.value = e.pageY - elInfoY.value;
      };
      compositionApi.onMounted(function () {
          document.addEventListener('mousemove', mouseMoveHandler);
      });
      compositionApi.onUnmounted(function () {
          document.removeEventListener('mousemove', mouseMoveHandler);
      });
      return {
          docX: docX,
          docY: docY,
          elX: elX,
          elY: elY,
          elInfoX: elInfoX,
          elInfoY: elInfoY,
          elInfoW: elInfoW,
          elInfoH: elInfoH
      };
  }

  function useMouseLeavePage(runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var isTracking = compositionApi.ref(false);
      var hasLeftPage = compositionApi.ref(false);
      var handleMouseOut = function (e) {
          var from = e.relatedTarget || e.toElement;
          var mouseHasLeftPage = !from || from.nodeName === 'HTML';
          hasLeftPage.value = mouseHasLeftPage;
      };
      var start = function () {
          if (isTracking.value)
              return;
          document.addEventListener('mouseout', handleMouseOut);
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          document.removeEventListener('mouseout', handleMouseOut);
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { hasLeftPage: hasLeftPage, isTracking: isTracking, start: start, stop: stop };
  }

  var defaultState = {
      angle: 0,
      type: 'landscape-primary'
  };
  function useOrientation(initialState, runOnMount) {
      if (initialState === void 0) { initialState = defaultState; }
      if (runOnMount === void 0) { runOnMount = true; }
      var isTracking = compositionApi.ref(false);
      var orientation = compositionApi.ref(initialState);
      var handleOrientationChange = function () {
          if (screen.orientation) {
              var _a = screen.orientation, angle = _a.angle, type = _a.type;
              orientation.value = { angle: angle, type: type };
          }
          else if (window.orientation) {
              orientation.value = {
                  angle: typeof window.orientation === 'number' ? window.orientation : 0,
                  type: ''
              };
          }
          else {
              orientation.value = initialState;
          }
      };
      var start = function () {
          if (isTracking.value)
              return;
          window.addEventListener('orientationchange', handleOrientationChange);
          handleOrientationChange();
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          window.removeEventListener('orientationchange', handleOrientationChange);
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { orientation: orientation, isTracking: isTracking, start: start, stop: stop };
  }

  var errorMsg$1 = 'ResizeObserver is not supported, please install a polyfill';
  function useSize(elRef, options, runOnMount) {
      if (options === void 0) { options = {}; }
      if (runOnMount === void 0) { runOnMount = true; }
      var isTracking = compositionApi.ref(false);
      var observedEntry = compositionApi.ref(null);
      var handleObserver = function (entries) {
          observedEntry.value = entries[0];
      };
      var observer = null;
      var start = function () {
          if (isTracking.value)
              return;
          if (!('ResizeObserver' in window))
              throw new Error(errorMsg$1);
          // Do not start if the observer is already initialized
          // or the elRef does not exist
          if (!elRef.value)
              return;
          observer = new window.ResizeObserver(handleObserver);
          observer.observe(elRef.value, options);
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          if (!observer)
              return;
          observer.disconnect();
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { observedEntry: observedEntry, isTracking: isTracking, start: start, stop: stop };
  }

  var normalizeParams = function (urlParamsObj) { return function (paramAcc, param) {
      paramAcc[param] = param in urlParamsObj ? urlParamsObj[param] : null;
      return paramAcc;
  }; };
  var getUrlParams = function (parameters) {
      var urlParamsObj = normalizeEntriesData(Array.from(new URLSearchParams(location.search).entries()));
      return parameters.reduce(normalizeParams(urlParamsObj), {});
  };
  function useSearchParams(parameters, runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var searchParams = compositionApi.ref(parameters.reduce(normalizeParams({}), {}));
      var isTracking = compositionApi.ref(false);
      var handleParamsChange = function () {
          return (searchParams.value = getUrlParams(parameters));
      };
      var start = function () {
          if (isTracking.value)
              return;
          patchHistoryMethodsOnce();
          handleParamsChange();
          window.addEventListener('popstate', handleParamsChange);
          window.addEventListener('pushstate', handleParamsChange);
          window.addEventListener('replacestate', handleParamsChange);
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          window.removeEventListener('popstate', handleParamsChange);
          window.removeEventListener('pushstate', handleParamsChange);
          window.removeEventListener('replacestate', handleParamsChange);
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { searchParams: searchParams, isTracking: isTracking, start: start, stop: stop };
  }

  function useScroll(elRef, ms, runOnMount) {
      if (ms === void 0) { ms = 150; }
      if (runOnMount === void 0) { runOnMount = true; }
      var isTracking = compositionApi.ref(false);
      var isScrolling = compositionApi.ref(false);
      var x = compositionApi.ref(0);
      var y = compositionApi.ref(0);
      var scrollingTimeout = null;
      var updateScrollStatus = function () {
          isScrolling.value = true;
          clearTimeout(scrollingTimeout);
          scrollingTimeout = setTimeout(function () { return (isScrolling.value = false); }, ms);
      };
      var updateWindowElement = function () {
          x.value = window.pageXOffset;
          y.value = window.pageYOffset;
      };
      var updateHTMLElement = function () {
          x.value = elRef.value.scrollLeft;
          y.value = elRef.value.scrollTop;
      };
      var updateElScrollPos = function () {
          if (!elRef.value)
              return;
          elRef.value === window ? updateWindowElement() : updateHTMLElement();
      };
      var handleScroll = function () {
          updateElScrollPos();
          updateScrollStatus();
      };
      var start = function () {
          if (isTracking.value)
              return;
          if (elRef.value) {
              elRef.value.addEventListener('scroll', handleScroll, {
                  capture: false,
                  passive: true
              });
              updateElScrollPos();
          }
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          if (elRef.value)
              elRef.value.removeEventListener('scroll', handleScroll);
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { x: x, y: y, isTracking: isTracking, isScrolling: isScrolling, start: start, stop: stop };
  }

  function useScrollbarWidth(runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var scrollbarWidth = compositionApi.ref(0);
      var getScrollbarWidth = function () {
          // https://stackoverflow.com/a/13382873/974107
          // Creating invisible container
          var outer = document.createElement('div');
          outer.style.visibility = 'hidden';
          outer.style.overflow = 'scroll'; // forcing scrollbar to appear
          outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps
          document.body.appendChild(outer);
          // Creating inner element and placing it in the container
          var inner = document.createElement('div');
          outer.appendChild(inner);
          // Calculating difference between container's full width and the child width
          var scrollbarWidthValue = outer.offsetWidth - inner.offsetWidth;
          // Removing temporary elements from the DOM
          if (outer.parentNode)
              outer.parentNode.removeChild(outer);
          scrollbarWidth.value = scrollbarWidthValue;
      };
      compositionApi.onMounted(function () { return runOnMount && getScrollbarWidth(); });
      return { scrollbarWidth: scrollbarWidth, getScrollbarWidth: getScrollbarWidth };
  }

  function useWindowSize(runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var width = compositionApi.ref(isClient ? window.innerWidth : Infinity);
      var height = compositionApi.ref(isClient ? window.innerHeight : Infinity);
      var isTracking = compositionApi.ref(false);
      var handleWindowResize = function () {
          width.value = window.innerWidth;
          height.value = window.innerHeight;
      };
      var start = function () {
          if (isTracking.value)
              return;
          window.addEventListener('resize', handleWindowResize);
          handleWindowResize();
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          window.removeEventListener('resize', handleWindowResize);
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { width: width, height: height, isTracking: isTracking, start: start, stop: stop };
  }

  function useIntervalFn(callback, ms, runOnMount) {
      if (ms === void 0) { ms = 0; }
      if (runOnMount === void 0) { runOnMount = true; }
      var isRunning = compositionApi.ref(false);
      var interval = null;
      var start = function () {
          if (interval)
              return;
          isRunning.value = true;
          interval = setInterval(callback, ms);
      };
      var stop = function () {
          clearInterval(interval);
          isRunning.value = false;
          interval = null;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { isRunning: isRunning, start: start, stop: stop };
  }

  function useInterval(ms, runOnMount) {
      if (ms === void 0) { ms = 0; }
      if (runOnMount === void 0) { runOnMount = true; }
      var counter = compositionApi.ref(0);
      var animHandler = function () {
          counter.value = counter.value + 1;
      };
      var _a = useIntervalFn(animHandler, ms, runOnMount), isRunning = _a.isRunning, start = _a.start, stop = _a.stop;
      return { isRunning: isRunning, counter: counter, start: start, stop: stop };
  }

  var getFps = function (fps) { return Number(compositionApi.isRef(fps) ? fps.value : fps); };
  var calcFpsInterval = function (fps) { return 1000 / fps; };
  var fpsLimit = 60;
  function useRafFn(callback, 
  // Note: a value equal to or greater than 60 will disable the fps check logic
  // giving maximum precision and smoothness
  fps, runOnMount) {
      if (fps === void 0) { fps = fpsLimit; }
      if (runOnMount === void 0) { runOnMount = true; }
      var isRunning = compositionApi.ref(false);
      // Using a computed here allows us to update fps
      // dynamically from user's input
      var fpsInterval = compositionApi.computed(function () { return calcFpsInterval(getFps(fps)); });
      var itWasIdle = false;
      var startTime = 0;
      var timeElapsed = 0;
      var timePausedTot = 0;
      var timeDelta = 0;
      var loop = function (timeStamp) {
          if (!startTime)
              startTime = timeStamp;
          if (!isRunning.value)
              return;
          // Store the time that the loop is idle so that we can
          // calculate the timeElapsed variable correctly and return
          // it to the user from within the callback
          if (itWasIdle) {
              timePausedTot = timeStamp - startTime - timeElapsed;
              itWasIdle = false;
          }
          // Adjust timeElapsed to account for startTime and timePausedTot
          timeElapsed = timeStamp - startTime - timePausedTot;
          // Always run the callback if fps is greater than fpsLimit
          var callbackShouldAlwaysRun = getFps(fps) >= fpsLimit;
          if (callbackShouldAlwaysRun) {
              // Store timeDelta for future computations
              timeDelta = timeElapsed;
              callback(timeElapsed);
          }
          // Run callback only when !callbackShouldAlwaysRun
          // and the given fps matches the lapsed time
          if (!callbackShouldAlwaysRun) {
              var elapsedTimeFromPrevLoop = Math.ceil(timeElapsed - timeDelta);
              if (elapsedTimeFromPrevLoop > fpsInterval.value) {
                  // Store timeDelta for future computations
                  timeDelta = timeElapsed;
                  callback(timeElapsed);
              }
          }
          // Run loop again recursively
          requestAnimationFrame(loop);
      };
      var start = function () {
          isRunning.value = true;
          requestAnimationFrame(loop);
      };
      var stop = function () {
          isRunning.value = false;
          itWasIdle = true;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return {
          isRunning: isRunning,
          start: start,
          stop: stop
      };
  }

  var fpsLimit$1 = 60;
  function useRaf(fps, runOnMount) {
      if (fps === void 0) { fps = fpsLimit$1; }
      if (runOnMount === void 0) { runOnMount = true; }
      var elapsed = compositionApi.ref(0);
      var animHandler = function (elapsedTime) {
          elapsed.value = elapsedTime;
      };
      var _a = useRafFn(animHandler, fps, runOnMount), isRunning = _a.isRunning, start = _a.start, stop = _a.stop;
      return {
          isRunning: isRunning,
          elapsed: elapsed,
          start: start,
          stop: stop
      };
  }

  function useTimeoutFn(callback, ms, runOnMount) {
      if (ms === void 0) { ms = 0; }
      if (runOnMount === void 0) { runOnMount = true; }
      var isReady = compositionApi.ref(null);
      var timeout = null;
      var start = function () {
          isReady.value = false;
          if (timeout)
              clearTimeout(timeout);
          timeout = setTimeout(function () {
              isReady.value = true;
              callback();
              timeout = null;
          }, ms);
      };
      var stop = function () {
          isReady.value = null;
          if (timeout) {
              clearTimeout(timeout);
              timeout = null;
          }
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { isReady: isReady, start: start, stop: stop };
  }

  var noop = function () { return null; };
  function useTimeout(ms, runOnMount) {
      if (ms === void 0) { ms = 0; }
      if (runOnMount === void 0) { runOnMount = true; }
      var _a = useTimeoutFn(noop, ms, runOnMount), isReady = _a.isReady, start = _a.start, stop = _a.stop;
      return { isReady: isReady, start: start, stop: stop };
  }

  function useBeforeUnload(isPageDirty, runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var isTracking = compositionApi.ref(false);
      var handleBeforeUnload = function (e) {
          // Show alert message only when isPageDirty is true
          if (isPageDirty.value)
              e.preventDefault();
      };
      var start = function () {
          if (isTracking.value)
              return;
          window.addEventListener('beforeunload', handleBeforeUnload);
          isTracking.value = true;
      };
      var stop = function () {
          if (!isTracking.value)
              return;
          window.removeEventListener('beforeunload', handleBeforeUnload);
          isTracking.value = false;
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return { isTracking: isTracking, start: start, stop: stop };
  }

  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  /**
   * Module exports.
   * @public
   */

  var parse_1 = parse;
  var serialize_1 = serialize;

  /**
   * Module variables.
   * @private
   */

  var decode = decodeURIComponent;
  var encode = encodeURIComponent;
  var pairSplitRegExp = /; */;

  /**
   * RegExp to match field-content in RFC 7230 sec 3.2
   *
   * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
   * field-vchar   = VCHAR / obs-text
   * obs-text      = %x80-FF
   */

  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

  /**
   * Parse a cookie header.
   *
   * Parse the given cookie header string into an object
   * The object has the various cookies as keys(names) => values
   *
   * @param {string} str
   * @param {object} [options]
   * @return {object}
   * @public
   */

  function parse(str, options) {
    if (typeof str !== 'string') {
      throw new TypeError('argument str must be a string');
    }

    var obj = {};
    var opt = options || {};
    var pairs = str.split(pairSplitRegExp);
    var dec = opt.decode || decode;

    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i];
      var eq_idx = pair.indexOf('=');

      // skip things that don't look like key=value
      if (eq_idx < 0) {
        continue;
      }

      var key = pair.substr(0, eq_idx).trim();
      var val = pair.substr(++eq_idx, pair.length).trim();

      // quoted values
      if ('"' == val[0]) {
        val = val.slice(1, -1);
      }

      // only assign once
      if (undefined == obj[key]) {
        obj[key] = tryDecode(val, dec);
      }
    }

    return obj;
  }

  /**
   * Serialize data into a cookie header.
   *
   * Serialize the a name value pair into a cookie string suitable for
   * http headers. An optional options object specified cookie parameters.
   *
   * serialize('foo', 'bar', { httpOnly: true })
   *   => "foo=bar; httpOnly"
   *
   * @param {string} name
   * @param {string} val
   * @param {object} [options]
   * @return {string}
   * @public
   */

  function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;

    if (typeof enc !== 'function') {
      throw new TypeError('option encode is invalid');
    }

    if (!fieldContentRegExp.test(name)) {
      throw new TypeError('argument name is invalid');
    }

    var value = enc(val);

    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError('argument val is invalid');
    }

    var str = name + '=' + value;

    if (null != opt.maxAge) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
      str += '; Max-Age=' + Math.floor(maxAge);
    }

    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError('option domain is invalid');
      }

      str += '; Domain=' + opt.domain;
    }

    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError('option path is invalid');
      }

      str += '; Path=' + opt.path;
    }

    if (opt.expires) {
      if (typeof opt.expires.toUTCString !== 'function') {
        throw new TypeError('option expires is invalid');
      }

      str += '; Expires=' + opt.expires.toUTCString();
    }

    if (opt.httpOnly) {
      str += '; HttpOnly';
    }

    if (opt.secure) {
      str += '; Secure';
    }

    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === 'string'
        ? opt.sameSite.toLowerCase() : opt.sameSite;

      switch (sameSite) {
        case true:
          str += '; SameSite=Strict';
          break;
        case 'lax':
          str += '; SameSite=Lax';
          break;
        case 'strict':
          str += '; SameSite=Strict';
          break;
        case 'none':
          str += '; SameSite=None';
          break;
        default:
          throw new TypeError('option sameSite is invalid');
      }
    }

    return str;
  }

  /**
   * Try decoding a string using a decoding function.
   *
   * @param {string} str
   * @param {function} decode
   * @private
   */

  function tryDecode(str, decode) {
    try {
      return decode(str);
    } catch (e) {
      return str;
    }
  }

  var cookie = {
  	parse: parse_1,
  	serialize: serialize_1
  };

  var Cookies = function () {
      var state = {
          set: function (name, value, opts) {
              if (name === void 0) { name = ''; }
              if (value === void 0) { value = ''; }
              if (opts === void 0) { opts = { path: '/' }; }
              value = typeof value === 'object' ? JSON.stringify(value) : value;
              document.cookie = cookie.serialize(name, value, opts);
          },
          get: function (name) {
              if (name === void 0) { name = ''; }
              var cookies = cookie.parse(document.cookie);
              var cookie$$1 = cookies[name];
              return cookie$$1;
          },
          remove: function (name, opts) {
              if (name === void 0) { name = ''; }
              if (opts === void 0) { opts = { path: '/', expires: new Date(0) }; }
              var cookie$$1 = state.get(name);
              opts.expires = new Date(0);
              if (typeof cookie$$1 !== 'undefined')
                  state.set(name, '', opts);
          }
      };
      return state;
  };

  var defaultOptions = {
      isParsing: false
  };
  function useCookie(cookieName, options, runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var _a = Object.assign({}, defaultOptions, options), isParsing = _a.isParsing, opts = __rest(_a, ["isParsing"]);
      var serializer = createSerializer(opts.serializer);
      var deserializer = createDeserializer(opts.deserializer);
      var cookieLib = Cookies();
      var cookie = compositionApi.ref(null);
      var getCookie = function () {
          var cookieVal = tryDeserialize(cookieLib.get(cookieName), deserializer, isParsing);
          if (!isNullOrUndefined(cookieVal))
              cookie.value = cookieVal;
      };
      var setCookie = function (
      // The user may pass a 'string', a 'number', a valid JSON object/array
      // or even a custom object when serializer/deserializer are defined
      // so it is better to set allowed cookie value as 'any'
      newVal, options) {
          var newCookieVal = trySerialize(newVal, serializer, isParsing);
          cookieLib.set(cookieName, newCookieVal, options);
          cookie.value = tryDeserialize(newCookieVal, deserializer, isParsing);
      };
      var removeCookie = function (options) {
          cookieLib.remove(cookieName, options);
          cookie.value = null;
      };
      compositionApi.onMounted(function () { return runOnMount && getCookie(); });
      return { cookie: cookie, getCookie: getCookie, setCookie: setCookie, removeCookie: removeCookie };
  }

  var abortError = 'AbortError';
  var isContentTypeJson = function (res) {
      var contentType = res.headers.get('content-type');
      return contentType && contentType.includes('application/json');
  };
  var getUrl = function (url) { return (compositionApi.isRef(url) ? url.value : url); };
  var fetchWrapper = function (url, opts) { return __awaiter(void 0, void 0, void 0, function () {
      var res, resData, _a;
      return __generator(this, function (_b) {
          switch (_b.label) {
              case 0: return [4 /*yield*/, fetch(getUrl(url), opts)];
              case 1:
                  res = _b.sent();
                  _a = isContentTypeJson(res);
                  if (!_a) return [3 /*break*/, 3];
                  return [4 /*yield*/, res.json()];
              case 2:
                  _a = (_b.sent());
                  _b.label = 3;
              case 3:
                  resData = _a;
                  return [2 /*return*/, { resData: resData, res: res }];
          }
      });
  }); };
  function useFetch(url, options, runOnMount) {
      var _this = this;
      if (options === void 0) { options = {}; }
      if (runOnMount === void 0) { runOnMount = true; }
      var data = compositionApi.ref(null);
      var status = compositionApi.ref(null);
      var statusText = compositionApi.ref(null);
      var isLoading = compositionApi.ref(false);
      var isFailed = compositionApi.ref(false);
      var isAborted = compositionApi.ref(false);
      var controller;
      var start = function () { return __awaiter(_this, void 0, void 0, function () {
          var signal, _a, resData, res, err_1;
          return __generator(this, function (_b) {
              switch (_b.label) {
                  case 0:
                      _b.trys.push([0, 2, , 3]);
                      controller = new AbortController();
                      signal = controller.signal;
                      isLoading.value = true;
                      isFailed.value = false;
                      isAborted.value = false;
                      return [4 /*yield*/, fetchWrapper(getUrl(url), __assign({ signal: signal }, options))];
                  case 1:
                      _a = _b.sent(), resData = _a.resData, res = _a.res;
                      data.value = resData;
                      isLoading.value = false;
                      isFailed.value = !res.ok;
                      status.value = res.status;
                      statusText.value = res.statusText;
                      return [3 /*break*/, 3];
                  case 2:
                      err_1 = _b.sent();
                      if (err_1.name === abortError)
                          isAborted.value = true;
                      isLoading.value = false;
                      isFailed.value = true;
                      status.value = 500;
                      statusText.value = err_1.message || err_1.name;
                      return [3 /*break*/, 3];
                  case 3: return [2 /*return*/];
              }
          });
      }); };
      var stop = function () {
          if (controller)
              controller.abort();
      };
      compositionApi.onMounted(function () { return runOnMount && start(); });
      compositionApi.onUnmounted(stop);
      return {
          data: data,
          status: status,
          statusText: statusText,
          isLoading: isLoading,
          isFailed: isFailed,
          isAborted: isAborted,
          start: start,
          stop: stop
      };
  }

  var defaultOptions$1 = {
      isParsing: false
  };
  function createStorage(storage, key, options) {
      var _a = Object.assign({}, defaultOptions$1, options), isParsing = _a.isParsing, opts = __rest(_a, ["isParsing"]);
      var serializer = createSerializer(opts.serializer);
      var deserializer = createDeserializer(opts.deserializer);
      var item = compositionApi.ref(null);
      var getItem = function () {
          try {
              var itemVal = tryDeserialize(storage.getItem(key), deserializer, isParsing);
              if (!isNullOrUndefined(itemVal))
                  item.value = itemVal;
          }
          catch (error) {
              // If user is in private mode or has storage restriction
              // sessionStorage/locationStorage can throw
          }
      };
      var setItem = function (
      // The user may pass a 'string', a 'number', a valid JSON object/array
      // or even a custom object when serializer/deserializer are defined
      // so it is better to set allowed newItemVal as 'any'
      newVal) {
          try {
              var newItemVal = trySerialize(newVal, serializer, isParsing);
              storage.setItem(key, newItemVal);
              item.value = tryDeserialize(newItemVal, deserializer, isParsing);
          }
          catch (error) {
              // If user is in private mode or has storage restriction
              // sessionStorage/locationStorage can throw
          }
      };
      var removeItem = function () {
          try {
              storage.removeItem(key);
              item.value = null;
          }
          catch (error) {
              // If user is in private mode or has storage restriction
              // sessionStorage/locationStorage can throw
              item.value = null;
          }
      };
      return {
          item: item,
          getItem: getItem,
          setItem: setItem,
          removeItem: removeItem
      };
  }

  function useLocalStorage(key, options, runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var _a = createStorage(localStorage, key, options), item = _a.item, getItem = _a.getItem, setItem = _a.setItem, removeItem = _a.removeItem;
      compositionApi.onMounted(function () { return runOnMount && getItem(); });
      return {
          item: item,
          getItem: getItem,
          setItem: setItem,
          removeItem: removeItem
      };
  }

  function useSessionStorage(key, options, runOnMount) {
      if (runOnMount === void 0) { runOnMount = true; }
      var _a = createStorage(sessionStorage, key, options), item = _a.item, getItem = _a.getItem, setItem = _a.setItem, removeItem = _a.removeItem;
      compositionApi.onMounted(function () { return runOnMount && getItem(); });
      return {
          item: item,
          getItem: getItem,
          setItem: setItem,
          removeItem: removeItem
      };
  }

  // Utility

  exports.getQuery = getQuery;
  exports.useClickAway = useClickAway;
  exports.useFullscreen = useFullscreen;
  exports.useGeolocation = useGeolocation;
  exports.useHover = useHover;
  exports.idleEventsList = idleEventsList;
  exports.useIdle = useIdle;
  exports.useIntersection = useIntersection;
  exports.useKey = useKey;
  exports.useLocation = useLocation;
  exports.useMedia = useMedia;
  exports.useMediaDevices = useMediaDevices;
  exports.useMouse = useMouse;
  exports.useMouseElement = useMouseElement;
  exports.useMouseLeavePage = useMouseLeavePage;
  exports.useOrientation = useOrientation;
  exports.useSize = useSize;
  exports.useSearchParams = useSearchParams;
  exports.useScroll = useScroll;
  exports.useScrollbarWidth = useScrollbarWidth;
  exports.useWindowSize = useWindowSize;
  exports.useIntervalFn = useIntervalFn;
  exports.useInterval = useInterval;
  exports.useRafFn = useRafFn;
  exports.useRaf = useRaf;
  exports.useTimeoutFn = useTimeoutFn;
  exports.useTimeout = useTimeout;
  exports.useBeforeUnload = useBeforeUnload;
  exports.useCookie = useCookie;
  exports.useFetch = useFetch;
  exports.useLocalStorage = useLocalStorage;
  exports.useSessionStorage = useSessionStorage;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
