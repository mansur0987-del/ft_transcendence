# Microservices Package

This package is meant to serve as a library for Remote Procedure Calling of Javascript functions. This project grew out of a desire to gain experience with a microservices style architecture for a few different projects I was working on.

## What?

A microservices architecture breaks the functionality of large monolithic applications into smaller units of functionality. This leads (theoretically) to easier maintenance, testing, and deployments.

In practice, we want to make each service communicate with another over some sort of transport mechanism (for example HTTP). So rather than having each service manually construct requests according to some abstract specification, we provide this library for you to require as a dependency which handles all the communications for you.

## How?

This package comes with two distinct sections- server and client.

* Client is the part used for interacting with remote services. You provide a hostname and port number for the remote service and get back a structured object representing the interface for that service. You can then use it like any other local API- all networking, request encoding and response parsing is handled for you.

* Server is used to expose your microservice API to the outside world. You implement your system as usual with the public API ready for use. Just require in the microservices library and set the port to listen on. Then register the functions you want to expose to the outside world.

## Example Server
```javascript
const connect = require('microservices').server;
const register = server(8000);

register('int', {
    args: [{ name: 'integer', type: 'Number' }],
    fn: x => x * 2
});

register('float', {
    args: [{ name: 'float', type: 'Number' }],
    fn: x => x * 2
});

register('foo.string', {
    args: [{ name: 'string', type: 'String' }],
    fn: x => x.length
});
```

## Example Client
```javascript
const connect = require('microservices').client;

connect('localhost', '8000').then(service => Promise.all([
    service.float(3.141),
    service.int(42),
    service.foo.string('hello, world!'),
])).then(result => {
    console.log(result);
}).catch(result => {
    console.log(result);
});
```
Everything in the library is Promise based. The call to connect to the service returns a promise which resolves with one argument- the service interface. Each remote call also returns a promise resolving to the result of that remote call.

## Known Limitations

* Functions can only return primitives right now (that's things like Numbers, Strings, simple Objects). It's likely that services would want to be able to send files and other things.

* The tests could cover much more ground. Existing tests can be run with 'npm test'.

* Documenting the acceptable types for function arguments would be handy (not much yet).

* Need to examine the specifics of error handling, either if the wrong parameters are supplied (in which case the client can stop the request before it goes out), or if something goes wrong on the service end of things.

## In Depth

### Server
The server operates using simple HTTP requests (via Express), and receives requests from the outside world via a simple JSON body.

```javascript
{
    "foo": "argument 'foo' has this value",
    "bar": 3.14159
}
```

There are two possible outcomes for all remote calls, success or failure.

#### Success

```javascript
{
    "success": true,
    "result": {
        "data": "Hello, world!"
    }
}
```

#### Failure

```javascript
{
    "success": false,
    "result": {
        "error": {
            "foo": "bar"
        }
    }
}
```
