'use strict';

const express = require('express');
const body = require('body-parser');
const _ = require('lodash');

const Definition = require('./lib/Definition');

const Error400 = require('./error/ErrorHTTP400');
const Error404 = require('./error/ErrorHTTP404');

function start(port) {
    const service = express();
    const schema = Object.create(null);

    // Middleware
    service.use(body.json());

    // RPC Calls
    service.post(/.+/, (request, response) => {
        // Slice off the leading slash and turn it into a lodash object path
        const path = request.path.slice(1).replace(/\//g, '.');

        const definition = _.get(schema, path);

        // If the path doesn't exist or hasn't resolved to a function definition then 404
        if (! definition || ! (definition instanceof Definition)) {
            throw new Error404();
        } else {
            // Check that all named arguments are there
            const args = definition.args.map(arg => {
                if (request.body[arg.name] === undefined) {
                    throw new Error400();
                } else {
                    return request.body[arg.name];
                }
            });

            Promise.resolve(definition.implementation.apply(null, args))
                .then(result => {
                    response.status(200).json({
                        success: true,
                        result: {
                            data: result,
                        },
                    });
                })
                .catch(error => {
                    response.status(500).json({
                        success: false,
                        result: {
                            error,
                        },
                    });
                });
        }
    });

    service.get('/connect', (request, response) => {
        function descend(obj, path = '') {
            let ret;

            if (obj instanceof Definition) {
                ret = [{ path, args: obj.args }];
            } else {
                ret = _.keys(obj).map(key => descend(obj[key], path.length ? `${path}.${key}` : `${key}`));
            }

            return _.flatten(ret);
        }

        response.status(200).json(
            JSON.stringify({
                schema: descend(schema),
            })
        );
    });

    // Handle Errors
    service.use((err, req, res, next) => {
        res.status(err.code).json({
            success: false,
            error: {
                message: err.message,
            },
        });

        next();
    });

    service.listen(port);

    function register(path, addition) {
        const definition = _.get(path);
        const name = _.chain(path).split('.').last();

        if (definition) {
            throw new Error(`Path '${path}' is not available to register.`);
        }

        _.set(schema, path, new Definition(name, addition.args, addition.fn));

        return register;
    }

    return register;
}

module.exports = start;
