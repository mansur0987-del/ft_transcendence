import {
  Fragment,
  computed,
  defineComponent,
  h,
  inject,
  isRef,
  isVNode,
  provide,
  reactive,
  readonly,
  renderSlot,
  toRef,
  toRefs,
  watch,
  watchEffect
} from "./chunk-G4DFXOZZ.js";
import "./chunk-7FP5O474.js";

// ../node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// ../node_modules/history/index.js
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
var readOnly = true ? function(obj) {
  return Object.freeze(obj);
} : function(obj) {
  return obj;
};
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
var BeforeUnloadEventType = "beforeunload";
var HashChangeEventType = "hashchange";
var PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$window = _options.window, window2 = _options$window === void 0 ? document.defaultView : _options$window;
  var globalHistory = window2.history;
  function getIndexAndLocation() {
    var _window$location = window2.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname,
      search,
      hash,
      state: state.usr || null,
      key: state.key || "default"
    })];
  }
  var blockedPopTx = null;
  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;
      var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];
      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index - nextIndex;
          if (delta) {
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        } else {
          true ? warning(
            false,
            // TODO: Write up a doc that explains our blocking strategy in
            // detail and link to it here so people can understand better what
            // is going on and how to avoid it.
            "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation."
          ) : void 0;
        }
      } else {
        applyTx(nextAction);
      }
    }
  }
  window2.addEventListener(PopStateEventType, handlePop);
  var action = Action.Pop;
  var _getIndexAndLocation2 = getIndexAndLocation(), index = _getIndexAndLocation2[0], location = _getIndexAndLocation2[1];
  var listeners = createEvents();
  var blockers = createEvents();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }
    return readOnly(_extends({
      pathname: location.pathname,
      hash: "",
      search: ""
    }, typeof to === "string" ? parsePath(to) : to, {
      state,
      key: createKey()
    }));
  }
  function getHistoryStateAndUrl(nextLocation, index2) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index2
    }, createHref(nextLocation)];
  }
  function allowTx(action2, location2, retry) {
    return !blockers.length || (blockers.call({
      action: action2,
      location: location2,
      retry
    }), false);
  }
  function applyTx(nextAction) {
    action = nextAction;
    var _getIndexAndLocation3 = getIndexAndLocation();
    index = _getIndexAndLocation3[0];
    location = _getIndexAndLocation3[1];
    listeners.call({
      action,
      location
    });
  }
  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      push(to, state);
    }
    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        window2.location.assign(url);
      }
      applyTx(nextAction);
    }
  }
  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      replace(to, state);
    }
    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];
      globalHistory.replaceState(historyState, "", url);
      applyTx(nextAction);
    }
  }
  function go(delta) {
    globalHistory.go(delta);
  }
  var history = {
    get action() {
      return action;
    },
    get location() {
      return location;
    },
    createHref,
    push,
    replace,
    go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);
      if (blockers.length === 1) {
        window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }
      return function() {
        unblock();
        if (!blockers.length) {
          window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  var _options2 = options, _options2$window = _options2.window, window2 = _options2$window === void 0 ? document.defaultView : _options2$window;
  var globalHistory = window2.history;
  function getIndexAndLocation() {
    var _parsePath = parsePath(window2.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? "" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? "" : _parsePath$hash;
    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname,
      search,
      hash,
      state: state.usr || null,
      key: state.key || "default"
    })];
  }
  var blockedPopTx = null;
  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;
      var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];
      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index - nextIndex;
          if (delta) {
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        } else {
          true ? warning(
            false,
            // TODO: Write up a doc that explains our blocking strategy in
            // detail and link to it here so people can understand better
            // what is going on and how to avoid it.
            "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation."
          ) : void 0;
        }
      } else {
        applyTx(nextAction);
      }
    }
  }
  window2.addEventListener(PopStateEventType, handlePop);
  window2.addEventListener(HashChangeEventType, function() {
    var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];
    if (createPath(nextLocation) !== createPath(location)) {
      handlePop();
    }
  });
  var action = Action.Pop;
  var _getIndexAndLocation6 = getIndexAndLocation(), index = _getIndexAndLocation6[0], location = _getIndexAndLocation6[1];
  var listeners = createEvents();
  var blockers = createEvents();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getBaseHref() {
    var base = document.querySelector("base");
    var href = "";
    if (base && base.getAttribute("href")) {
      var url = window2.location.href;
      var hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href;
  }
  function createHref(to) {
    return getBaseHref() + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }
    return readOnly(_extends({
      pathname: location.pathname,
      hash: "",
      search: ""
    }, typeof to === "string" ? parsePath(to) : to, {
      state,
      key: createKey()
    }));
  }
  function getHistoryStateAndUrl(nextLocation, index2) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index2
    }, createHref(nextLocation)];
  }
  function allowTx(action2, location2, retry) {
    return !blockers.length || (blockers.call({
      action: action2,
      location: location2,
      retry
    }), false);
  }
  function applyTx(nextAction) {
    action = nextAction;
    var _getIndexAndLocation7 = getIndexAndLocation();
    index = _getIndexAndLocation7[0];
    location = _getIndexAndLocation7[1];
    listeners.call({
      action,
      location
    });
  }
  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      push(to, state);
    }
    true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")") : void 0;
    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1];
      try {
        globalHistory.pushState(historyState, "", url);
      } catch (error) {
        window2.location.assign(url);
      }
      applyTx(nextAction);
    }
  }
  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      replace(to, state);
    }
    true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(to) + ")") : void 0;
    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1];
      globalHistory.replaceState(historyState, "", url);
      applyTx(nextAction);
    }
  }
  function go(delta) {
    globalHistory.go(delta);
  }
  var history = {
    get action() {
      return action;
    },
    get location() {
      return location;
    },
    createHref,
    push,
    replace,
    go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);
      if (blockers.length === 1) {
        window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }
      return function() {
        unblock();
        if (!blockers.length) {
          window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}
function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }
  var _options3 = options, _options3$initialEntr = _options3.initialEntries, initialEntries = _options3$initialEntr === void 0 ? ["/"] : _options3$initialEntr, initialIndex = _options3.initialIndex;
  var entries = initialEntries.map(function(entry) {
    var location2 = readOnly(_extends({
      pathname: "/",
      search: "",
      hash: "",
      state: null,
      key: createKey()
    }, typeof entry === "string" ? parsePath(entry) : entry));
    true ? warning(location2.pathname.charAt(0) === "/", "Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: " + JSON.stringify(entry) + ")") : void 0;
    return location2;
  });
  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);
  var action = Action.Pop;
  var location = entries[index];
  var listeners = createEvents();
  var blockers = createEvents();
  function createHref(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }
    return readOnly(_extends({
      pathname: location.pathname,
      search: "",
      hash: ""
    }, typeof to === "string" ? parsePath(to) : to, {
      state,
      key: createKey()
    }));
  }
  function allowTx(action2, location2, retry) {
    return !blockers.length || (blockers.call({
      action: action2,
      location: location2,
      retry
    }), false);
  }
  function applyTx(nextAction, nextLocation) {
    action = nextAction;
    location = nextLocation;
    listeners.call({
      action,
      location
    });
  }
  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      push(to, state);
    }
    true ? warning(location.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.push(" + JSON.stringify(to) + ")") : void 0;
    if (allowTx(nextAction, nextLocation, retry)) {
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      applyTx(nextAction, nextLocation);
    }
  }
  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);
    function retry() {
      replace(to, state);
    }
    true ? warning(location.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.replace(" + JSON.stringify(to) + ")") : void 0;
    if (allowTx(nextAction, nextLocation, retry)) {
      entries[index] = nextLocation;
      applyTx(nextAction, nextLocation);
    }
  }
  function go(delta) {
    var nextIndex = clamp(index + delta, 0, entries.length - 1);
    var nextAction = Action.Pop;
    var nextLocation = entries[nextIndex];
    function retry() {
      go(delta);
    }
    if (allowTx(nextAction, nextLocation, retry)) {
      index = nextIndex;
      applyTx(nextAction, nextLocation);
    }
  }
  var history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return location;
    },
    createHref,
    push,
    replace,
    go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      return blockers.push(blocker);
    }
  };
  return history;
}
function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
function promptBeforeUnload(event) {
  event.preventDefault();
  event.returnValue = "";
}
function createEvents() {
  var handlers = [];
  return {
    get length() {
      return handlers.length;
    },
    push: function push(fn) {
      handlers.push(fn);
      return function() {
        handlers = handlers.filter(function(handler) {
          return handler !== fn;
        });
      };
    },
    call: function call(arg) {
      handlers.forEach(function(fn) {
        return fn && fn(arg);
      });
    }
  };
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function createPath(_ref) {
  var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  var parsedPath = {};
  if (path) {
    var hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    var searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}

// ../node_modules/vue-router-dom/dist-web/index.js
var ROUTE_CONTEXT = Symbol("ROUTE_CONTEXT");
var LOCATION_CONTEXT = Symbol("LOCATION_CONTEXT");
var Router = defineComponent({
  name: "Router",
  props: {
    location: { required: true, type: Object },
    navigator: { required: true, type: Object },
    action: {
      required: false,
      type: String,
      default: Action.Pop
    },
    static: { required: false, type: Boolean, default: false }
  },
  setup(props, { slots }) {
    provide(LOCATION_CONTEXT, props);
    return () => renderSlot(slots, "default");
  }
});
var useReducer = (reducer, initialState) => {
  const state = reactive(initialState);
  const dispatch = (...arg) => {
    reducer(state, ...arg);
  };
  return [readonly(state), dispatch];
};
var BrowserRouter = defineComponent({
  name: "BrowserRouter",
  props: {
    window: {
      required: false,
      type: Object
    }
  },
  setup(props, { slots }) {
    const history = computed(() => createBrowserHistory({
      window: props.window
    }));
    const [state, dispatch] = useReducer((state2, { action, location }) => {
      state2.action = action;
      state2.location = location;
    }, {
      action: history.value.action,
      location: history.value.location
    });
    watch(history, (history2) => history2.listen(dispatch), {
      flush: "sync",
      immediate: true
    });
    return () => h(Router, {
      location: state.location,
      action: state.action,
      navigator: history.value
    }, { default: slots.default });
  }
});
var throwError = (error) => {
  throw new Error(`[vue-router-dom] ${error}`);
};
function assert(condition, message) {
  if (!condition) {
    throwError(message);
  }
}
var useLocation = () => {
  const locationContext = inject(LOCATION_CONTEXT, null);
  assert(locationContext, `useLocation() may be used only in the context of a <Router> component.`);
  return toRef(locationContext, "location");
};
var trimTrailingSlashes = (path) => path.replace(/\/+$/, "");
var normalizeSlashes = (path) => path.replace(/\/\/+/g, "/");
var joinPaths = (paths) => normalizeSlashes(paths.join("/"));
var splitPath = (path) => normalizeSlashes(path).split("/");
var resolvePathname = (toPathname, fromPathname) => {
  const segments = splitPath(trimTrailingSlashes(fromPathname));
  const relativeSegments = splitPath(toPathname);
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? joinPaths(segments) : "/";
};
var resolvePath = (to, fromPathname = "/") => {
  const { pathname: toPathname, search = "", hash = "" } = typeof to === "string" ? parsePath(to) : to;
  const pathname = toPathname ? resolvePathname(toPathname, toPathname.startsWith("/") ? "/" : fromPathname) : fromPathname;
  return { pathname, search, hash };
};
var useRouteContext = () => inject(ROUTE_CONTEXT, computed(() => ({
  pathname: "",
  outlet: null,
  params: {},
  route: null
})));
var useOutlet = () => {
  const context = useRouteContext();
  return computed(() => context.value.outlet);
};
var useNavigate = () => {
  const locationContext = inject(LOCATION_CONTEXT, null);
  assert(locationContext, `useNavigate() may be used only in the context of a <Router> component.`);
  const navigator = toRef(locationContext, "navigator");
  const context = useRouteContext();
  const pathname = computed(() => context.value.pathname);
  const navigate = (to, { state, replace = false } = {}) => {
    const navigatorValue = navigator.value;
    if (typeof to === "number") {
      return navigatorValue.go(to);
    }
    const path = resolvePath(to, pathname.value);
    (replace ? navigatorValue.replace : navigatorValue.push)(path, state);
  };
  return navigate;
};
var useComputedCallback = (value) => value instanceof Function ? computed(value) : isRef(value) ? value : computed(() => value);
var useResolvedPath = (toValue) => {
  const to = useComputedCallback(toValue);
  const context = useRouteContext();
  const pathname = computed(() => context.value.pathname);
  return computed(() => resolvePath(to.value, pathname.value));
};
var useHref = (toValue) => {
  const locationContext = inject(LOCATION_CONTEXT, null);
  assert(locationContext, `useHref() may be used only in the context of a <Router> component.`);
  const navigator = toRef(locationContext, "navigator");
  const to = useComputedCallback(toValue);
  const path = useResolvedPath(to);
  return computed(() => navigator.value.createHref(path.value));
};
var linkProps = {
  replace: {
    default: false,
    required: false,
    type: Boolean
  },
  tag: {
    default: "a",
    required: false,
    type: String
  },
  to: { default: "", required: true, type: [String, Object] },
  state: {
    default: void 0,
    required: false,
    type: Object
  }
};
var Link = defineComponent({
  name: "Link",
  props: linkProps,
  emits: { click: null },
  setup(props, { slots, emit }) {
    const { to, replace } = toRefs(props);
    const href = useHref(to);
    const location = useLocation();
    const path = useResolvedPath(to);
    const navigate = useNavigate();
    const handleClick = (event) => {
      emit("click", event);
      event.stopPropagation();
      event.preventDefault();
      const pathValue = path.value;
      const replaceValue = !!replace.value || createPath(location.value) === createPath(pathValue);
      navigate(pathValue, {
        replace: replaceValue,
        state: props.state
      });
    };
    return () => h(props.tag, {
      href: href.value,
      onClick: handleClick
    }, { default: slots.default });
  }
});
var MemoryRouter = defineComponent({
  name: "MemoryRouter",
  props: {
    initialEntries: {
      required: false,
      type: Array
    },
    initialIndex: { required: false, type: Number }
  },
  setup(props, { slots }) {
    const history = computed(() => createMemoryHistory({
      initialEntries: props.initialEntries,
      initialIndex: props.initialIndex
    }));
    const [state, dispatch] = useReducer((state2, { action, location }) => {
      state2.action = action;
      state2.location = location;
    }, {
      action: history.value.action,
      location: history.value.location
    });
    watch(history, (history2) => history2.listen(dispatch), {
      flush: "sync",
      immediate: true
    });
    return () => h(Router, {
      location: state.location,
      action: state.action,
      navigator: history.value
    }, { default: slots.default });
  }
});
var useCaseSensitive = (caseSensitiveValue, stringValue) => {
  const caseSensitive = useComputedCallback(caseSensitiveValue);
  const string = useComputedCallback(stringValue);
  return computed(() => {
    const stringValue2 = string.value;
    return caseSensitive.value ? stringValue2 : stringValue2.toLowerCase();
  });
};
var NavLink = defineComponent({
  name: "NavLink",
  props: {
    activeClassName: {
      default: "",
      required: false,
      type: String
    },
    activeStyle: {
      default: () => ({}),
      required: false,
      type: Object
    },
    caseSensitive: {
      default: false,
      required: false,
      type: Boolean
    },
    end: {
      default: false,
      required: false,
      type: Boolean
    },
    ariaCurrent: { default: "page", type: String, required: false },
    ...linkProps
  },
  setup(props, { slots }) {
    const location = useLocation();
    const { to, caseSensitive } = toRefs(props);
    const path = useResolvedPath(to);
    const locationPathname = computed(() => location.value.pathname);
    const toPathname = computed(() => path.value.pathname);
    const caseSensitiveLocationPathname = useCaseSensitive(caseSensitive, locationPathname);
    const caseSensitiveToPathname = useCaseSensitive(caseSensitive, toPathname);
    const isActive = computed(() => {
      const locationPathname2 = caseSensitiveLocationPathname.value;
      const toPathname2 = caseSensitiveToPathname.value;
      return props.end ? locationPathname2 === toPathname2 : locationPathname2.startsWith(toPathname2);
    });
    const ariaCurrent = computed(() => isActive.value ? props.ariaCurrent : void 0);
    const className = computed(() => isActive.value && props.activeClassName);
    const style = computed(() => isActive.value && props.activeStyle);
    return () => h(Link, {
      style: style.value,
      class: className.value,
      to: props.to,
      ariaCurrent: ariaCurrent.value
    }, { default: slots.default });
  }
});
var Outlet = defineComponent({
  name: "Outlet",
  setup() {
    const outletElement = useOutlet();
    return () => outletElement.value;
  }
});
var Route = defineComponent({
  name: "Route",
  props: {
    path: {
      default: "",
      required: false,
      type: String
    },
    caseSensitive: {
      default: false,
      required: false,
      type: Boolean
    },
    element: {
      default: () => h(Outlet),
      required: false,
      type: Object
    }
  },
  setup(props, { slots }) {
    return () => renderSlot(slots, "element", void 0, () => [props.element]);
  }
});
var compilePath = (path, caseSensitive, end) => {
  const keys = [];
  let source = "^(" + path.replace(/^\/*/, "/").replace(/\/?\*?$/, "").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, key) => {
    keys.push(key);
    return "([^\\/]+)";
  }) + ")";
  if (path.endsWith("*")) {
    if (path.endsWith("/*")) {
      source += "\\/?";
    }
    keys.push("*");
    source += "(.*)";
  } else if (end) {
    source += "\\/?";
  }
  if (end)
    source += "$";
  const flags = caseSensitive ? void 0 : "i";
  const matcher = new RegExp(source, flags);
  return [matcher, keys];
};
var safelyDecodeURIComponent = (value, paramName) => {
  try {
    return decodeURIComponent(value.replace(/\+/g, " "));
  } catch (error) {
    assert(false, `The value for the URL param "${paramName}" will not be decoded because the string "${value}" is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`);
  }
};
var matchPath = (pattern, pathname) => {
  if (typeof pattern === "string") {
    pattern = { path: pattern };
  }
  const { path, caseSensitive = false, end = true } = pattern;
  const [matcher, paramNames] = compilePath(path, caseSensitive, end);
  const match = pathname.match(matcher);
  if (!match)
    return null;
  const matchedPathname = match[1];
  const values = match.slice(2);
  const params = paramNames.reduce((memo, paramName, index) => {
    memo[paramName] = safelyDecodeURIComponent(values[index], paramName);
    return memo;
  }, {});
  return { path, pathname: matchedPathname, params };
};
var paramRe = /^:\w+$/;
var dynamicSegmentValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function matchRouteBranch(branch, pathname) {
  const routes = branch[1];
  let matchedPathname = "/";
  let matchedParams = {};
  const matches = [];
  for (let i = 0; i < routes.length; ++i) {
    const route = routes[i];
    const remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    const routeMatch = matchPath({
      path: route.path,
      caseSensitive: route.caseSensitive,
      end: i === routes.length - 1
    }, remainingPathname);
    if (!routeMatch)
      return null;
    matchedPathname = joinPaths([matchedPathname, routeMatch.pathname]);
    matchedParams = { ...matchedParams, ...routeMatch.params };
    matches.push({
      route,
      pathname: matchedPathname,
      params: matchedParams
    });
  }
  return matches;
}
function compareIndexes(a, b) {
  const siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function stableSort(array, compareItems) {
  const copy = array.slice(0);
  array.sort((a, b) => compareItems(a, b) || copy.indexOf(a) - copy.indexOf(b));
}
function computeScore(path) {
  const segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function rankRouteBranches(branches) {
  const pathScores = branches.reduce((memo, [path]) => {
    memo[path] = computeScore(path);
    return memo;
  }, {});
  stableSort(branches, (a, b) => {
    const [aPath, , aIndexes] = a;
    const aScore = pathScores[aPath];
    const [bPath, , bIndexes] = b;
    const bScore = pathScores[bPath];
    return aScore !== bScore ? bScore - aScore : compareIndexes(aIndexes, bIndexes);
  });
}
function flattenRoutes(routes, branches = [], parentPath = "", parentRoutes = [], parentIndexes = []) {
  routes.forEach((route, index) => {
    const path = joinPaths([parentPath, route.path]);
    const routes2 = parentRoutes.concat(route);
    const indexes = parentIndexes.concat(index);
    if (route.children) {
      flattenRoutes(route.children, branches, path, routes2, indexes);
    }
    branches.push([path, routes2, indexes]);
  });
  return branches;
}
var matchRoutes = (routes, location, basename = "") => {
  if (typeof location === "string") {
    location = parsePath(location);
  }
  let pathname = location.pathname || "/";
  if (basename) {
    const base = basename.replace(/^\/*/, "/").replace(/\/+$/, "");
    if (pathname.startsWith(base)) {
      pathname = pathname === base ? "/" : pathname.slice(base.length);
    } else {
      return null;
    }
  }
  const branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; i++) {
    matches = matchRouteBranch(branches[i], pathname);
  }
  return matches;
};
var createRoutesFromArray = (partialRouteObjects) => {
  return partialRouteObjects.map((partialRoute) => {
    const route = {
      path: partialRoute.path || "/",
      caseSensitive: partialRoute.caseSensitive === true,
      element: partialRoute.element || h(Outlet)
    };
    if (partialRoute.children) {
      route.children = createRoutesFromArray(partialRoute.children);
    }
    return route;
  });
};
var Provide = defineComponent({
  props: {
    injectionKey: { required: true, type: [String, Symbol] },
    value: null
  },
  setup(props, { slots }) {
    provide(props.injectionKey, computed(() => props.value));
    return () => renderSlot(slots, "default");
  }
});
var useJoinPaths = (pathsValue) => {
  const paths = useComputedCallback(pathsValue);
  return computed(() => joinPaths(paths.value));
};
var useRoutes_ = (routesValue, basenameValue = "") => {
  const routes = useComputedCallback(routesValue);
  const defaultBasename = useComputedCallback(basenameValue);
  const context = useRouteContext();
  const parentRoute = computed(() => context.value.route);
  const parentPathname = computed(() => context.value.pathname);
  const parentParams = computed(() => context.value.params);
  const location = useLocation();
  const parentPath = computed(() => parentRoute.value && parentRoute.value.path);
  watchEffect(() => {
    const parentRouteValue = parentRoute.value;
    if (parentRouteValue && !parentRouteValue.path.endsWith("*")) {
      console.warn(`You rendered descendant <Routes> (or called \`useRoutes\`) at "${parentPathname.value}" (under <Route path="${parentPath.value}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath.value}"> to <Route path="${parentPath.value}/*">.`);
    }
  });
  const joinedPaths = useJoinPaths(() => [
    parentPathname.value,
    defaultBasename.value
  ]);
  const basename = computed(() => defaultBasename.value ? joinedPaths.value : parentPathname.value);
  const matches = computed(() => matchRoutes(routes.value, location.value, basename.value));
  return computed(() => matches.value && matches.value.reduceRight((outlet, { params, pathname, route }) => h(Provide, {
    injectionKey: ROUTE_CONTEXT,
    value: {
      outlet,
      params: { ...parentParams.value, ...params },
      pathname: joinPaths([basename.value, pathname]),
      route
    }
  }, { default: () => [route.element] }), null));
};
var useRoutes = (partialRoutesValue, basename = "") => {
  const partialRoutes = useComputedCallback(partialRoutesValue);
  const routes = computed(() => createRoutesFromArray(partialRoutes.value));
  return useRoutes_(routes, basename);
};
var createRoutesFromChildren = (normalizedChildren) => {
  const routes = [];
  const children = Array.isArray(normalizedChildren) ? normalizedChildren : normalizedChildren instanceof Object ? [renderSlot(normalizedChildren, "default")] : [];
  for (const element of children) {
    if (!isVNode(element)) {
      continue;
    }
    if (element.type === "template" || element.type === Fragment) {
      routes.push(...createRoutesFromChildren(element.children));
      continue;
    }
    const { path, caseSensitive } = element.props || {};
    const route = {
      path: path || "/",
      caseSensitive: caseSensitive === true,
      element
    };
    if (element.children) {
      const childRoutes = createRoutesFromChildren(element.children);
      if (childRoutes.length) {
        route.children = childRoutes;
      }
    }
    routes.push(route);
  }
  return routes;
};
var Routes = defineComponent({
  name: "Routes",
  props: { basename: { default: "", required: false, type: String } },
  setup(props, { slots }) {
    const routes = computed(() => createRoutesFromChildren([renderSlot(slots, "default")]));
    const vnode = useRoutes_(routes, () => props.basename);
    return () => vnode.value;
  }
});
var components = Object.freeze({
  __proto__: null,
  BrowserRouter,
  Link,
  MemoryRouter,
  NavLink,
  Outlet,
  Route,
  Router,
  Routes
});
var useBlocker = (blocker, whenValue = true) => {
  const locationContext = inject(LOCATION_CONTEXT, null);
  assert(locationContext, `useBlocker() may be used only in the context of a <Router> component.`);
  const when = useComputedCallback(whenValue);
  const navigator = toRef(locationContext, "navigator");
  watchEffect((onCleanup) => {
    if (!when.value) {
      return;
    }
    const unblock = navigator.value.block((tx) => {
      blocker({
        ...tx,
        retry() {
          unblock();
          tx.retry();
        }
      });
    });
    onCleanup(unblock);
  });
};
var useMatch = (patternValue) => {
  const pattern = useComputedCallback(patternValue);
  const context = useRouteContext();
  const pathname = computed(() => context.value.pathname);
  const match = computed(() => matchPath(pattern.value, pathname.value));
  return match;
};
var useParams = () => {
  const context = useRouteContext();
  return computed(() => context.value.params);
};
var usePrompt = (messageValue, whenValue = true) => {
  const message = useComputedCallback(messageValue);
  useBlocker((tx) => {
    if (window.confirm(message.value)) {
      tx.retry();
    }
  }, whenValue);
};
var createSearchParams = (init = "") => new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
  const value = init[key];
  return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
}, []));
var useSetSearchParams = () => {
  const navigate = useNavigate();
  return (nextInit, navigateOptions) => {
    navigate(`?${createSearchParams(nextInit)}`, navigateOptions);
  };
};
var useGetSearchParams = (defaultInitValue) => {
  const defaultInit = useComputedCallback(defaultInitValue);
  const defaultSearchParams = computed(() => createSearchParams(defaultInit.value));
  const location = useLocation();
  const searchParams = computed(() => createSearchParams(location.value.search));
  return computed(() => {
    const defaultSearchParamsValue = defaultSearchParams.value;
    const searchParamsValue = createSearchParams(searchParams.value);
    for (const key of defaultSearchParamsValue.keys()) {
      if (!searchParamsValue.has(key)) {
        defaultSearchParamsValue.getAll(key).forEach((value) => {
          searchParamsValue.append(key, value);
        });
      }
    }
    return searchParamsValue;
  });
};
var useSearchParams = (defaultInit) => {
  const searchParams = useGetSearchParams(defaultInit);
  const setSearchParams = useSetSearchParams();
  return [searchParams, setSearchParams];
};
var generatePath = (path, params = {}) => {
  return path.replace(/:(\w+)/g, (_, key) => {
    assert(params[key] != null, `Missing ":${key}" param`);
    return params[key];
  }).replace(/\/*\*$/, () => params["*"] == null ? "" : params["*"].replace(/^\/*/, "/"));
};
var install = (app) => {
  for (const key in components) {
    app.component(key, components[key]);
  }
};
export {
  Action,
  BrowserRouter,
  LOCATION_CONTEXT,
  Link,
  MemoryRouter,
  NavLink,
  Outlet,
  ROUTE_CONTEXT,
  Route,
  Router,
  Routes,
  createBrowserHistory,
  createHashHistory,
  createMemoryHistory,
  createPath,
  createRoutesFromArray,
  createRoutesFromChildren,
  generatePath,
  install,
  matchPath,
  matchRoutes,
  parsePath,
  resolvePath,
  useBlocker,
  useHref,
  useLocation,
  useMatch,
  useNavigate,
  useOutlet,
  useParams,
  usePrompt,
  useResolvedPath,
  useRoutes,
  useSearchParams
};
//# sourceMappingURL=vue-router-dom.js.map
